<?xml version="1.0"?>
<WiREXMLDoc xmlns:dt="urn:schemas-microsoft-com:datatypes"><MeasurementInformation><Measurement clsid="{EA41D170-63DA-11D5-84E9-009027FE0FB4}" xmlns:vt="urn:renishaw:vartypes"><Name vt:type="VT_BSTR">Single scan measurement</Name><Description vt:type="VT_BSTR">A single scan measurement generated by the WiRE spectral acquisition wizard.</Description><Language vt:type="VT_BSTR">VBScript</Language><Code vt:type="VT_BSTR">' StdMeasurement.vbs - Copyright (C) 2001 Renishaw plc
'
' This is the VBScript code used for a standard data acquisition
'
' The basic measurement supports performing a single scan of any
' configured scan type using the configured instrument state. It
' also supports a time series collection where a number of data collections
' may be taken from the same point over a period of time.
'
' Required Named Items:
'  InstrumentState  : the desired hardware state for running this measurement
'  Scan             : A configured scan object
'  FocusTrack       : The Focus Track object
'
' Properties used:
'  MeasurementType : a string name for the type of measurement.
'  AcquisitionCount : the number of acquisitions to be done, as defined by the wizard.
'
'  TimeSeriesCount   : The number of data collections to do
'  TimeSeriesInterval: The delay between each collection
'  BleachTime        : An optional delay before data collection to allow sample
'                      bleaching.
'
'  DepthSeriesStartPos :The start position for the depth series.
'  DepthSeriesFinalPos : The final position for the depth series.
'  DepthSeriesInterval : The vertical step size between each point.
'  DepthSeriesCount    : The number of points in a depth series acquisition
'
'  TemperatureSeriesCount    : The number of steps in a temperature series.
'  TemperatureSeriesInterval : The interval in degrees C for each step
'  TemperatureSeriesStart    : The starting temperature for the measurement
'  TemperatureSeriesRamp     : The rate of temperature change.
'  TemperatureSeriesFinal    : The temperature to set before exiting. Can be used to restore the initial temp.
'  TemperatureSeriesHold     : The hold time in ms after each temperature has been achieved before collecting. Optional
'  or
'  TemperatureRamps    : The temperature ramps object
'  FocusTrackEnabled  : Are we using focus track?
'  FocusTrackInterval : Perform focus every nth scan
'
'  UserTriggeredMeasurement: show a dialog before each acquisition to allow the user to trigger
'  CollectTemperatureValue: for every acquisition, read the TMS temperature
'  MaximizeWhitelight:   show whitelight unless actually acquiring raman data (uses illuminationLampBrightnessPercent)
'
'  imageCapture : 0 = None, 1 = Before, 2 = After, 3 = Both
'  imageCapturePause: number of millisecs to wait for the white light to settle.
'  illuminationLampOn: flag indicating whether or not the illumination lamp should 
'                       be used for the image capture. N.B The image capture mode
'                       can be triggered from either the imageCapture flag above OR
'                       from the Temperature measurements; this flag is applicable to both.
'  illuminationLampBrightnessPercent: when the lamp is turned on, it is set to this value.
'
'  reportCameraStatus: request some additional debugging information from the camera
'  responseCalibration: enable or disable the use of Response Calibration
'  restoreInstrumentState: preserve and restore the instrument state after running
'  closeLaserShutter: force the laser shutter closed on measurement complete.
'  cycling: boolean flag set to true if this is a cycling measurement.
'  minimizeLaserExposure: keep the laser shutter closed as much as possible
'  persistentTempFile: true if unnamed measurements create persistent temp files (default: true)
'
'  UseFixedZ : if present indicates that a fixed z should be used for the measurement

Option Explicit
Const s_Version = "5.0.1.7483"

' The following comments load symbols from these type libraries.
' TypeLib: WIRESYSTEMLib 1.0 = {f8c953c2-00fc-11d5-8004-005004f62988}
' TypeLib: WIREMOTORSLib 1.0 = {6F067EE0-6158-11D4-94D9-005004F62988}
' TypeLib: WIREXYZLib 1.0 = {DAE0FF43-C76E-11D4-8945-00003C508B6F}
' TypeLib: WIREAREAKEYLib 1.0 = {D3C457FF-7171-4AFF-9FA9-3A53DE868978}
' TypeLib: WIREFILEHANDLERLib 1.0 = {561A42DF-1A4C-46DD-97B3-0FCA9CB4FBF5}
' TypeLib: WIRESCAN2Lib 1.0 = {9EFE94A0-77E8-11D5-A49F-0060B0CE0147}
' TypeLib: WIREPODULELib 1.0 = {34BEA794-3631-4B81-8961-38AAF888D694}
' TypeLib: WiRETemperatureRampsLib 1.0 = {5B8E254F-3C0F-4FEA-B7B5-A5469D6848F4}
' TypeLib: WiREMmtCOMPlugInsLib 1.0 = {eeb31125-fb6d-47c0-b3c1-c2cf3c90e50b}

' -------------------------------------------------------------------------
' Scan use mode.
Private Const eSingleScan    = 0
Private Const eCompleteSeries    = 1
Private Const eInteruptedSeries    = 2
Private Const eCustomSeries    = 3

' -------------------------------------------------------------------------
' Series scan features. can be OR'd together 
Private Const eSingle  = 0
Private Const eTiming  = 1 ' eTime is one of WIREFILEHANDLERLib.EDataType
Private Const eDepths  = 2
Private Const eThermal = 4 ' eTemperature is one of EDataType
Private Const eXYArea  = 8
Private Const eTriggeredSeries  = 16
Private Const eThermal2 = 32 ' uses the temperature ramps object. Not so much a temperature series as a simple series with temperatures
'Private Const eTriggeredSeries  = 16 ' see above
Private Const eSurface = 64

' Our timed-out failure scan completion status string.
Private Const g_sFailedTimeout = "Failed Timed out"

Private Const ePlugInOperation_Pre = 0
Private Const ePlugInOperation_Init = 1
Private Const ePlugInOperation_Post = 2
Private Const ePlugInOperation_Final = 3

Private Const ePlugInResult_Aborted = 2
Private Const ePlugInResult_Error = 3

' -------------------------------------------------------------------------
' Global Variables
'
Private g_nUpdates          : g_nUpdates = 0
Private g_bDebugMeasurement : g_bDebugMeasurement = False
Private g_bSleeping         : g_bSleeping = False
Private g_InstrumentStateApplied : g_InstrumentStateApplied = -1
Private Logger              : Set Logger = Nothing
Private Acquisition         : Set Acquisition = Nothing
Private Instrument          : Set Instrument = Nothing
Private ResponseCalibration : Set ResponseCalibration = Nothing
Private g_oInitialState     : Set g_oInitialState = Nothing
Private g_parentHWND        : g_parentHWND = 0
Private g_AbortReqCount        : g_AbortReqCount = 0    ' used to skip the abort requests if called more than 3 times.

Private g_bUseCollectWarning : g_bUseCollectWarning = True ' Should the user see the collection warning dialog on non-podule systems
Private g_sDataCollectTitle : g_sDataCollectTitle = "WiRE : Check laser position on sample"
Private g_sDataCollectMessage : g_sDataCollectMessage = ""
Private g_sImageCollectTitle : g_sImageCollectTitle = "WiRE : Check sample is visible"
Private g_sImageCollectMessage : g_sImageCollectMessage = ""
private g_DataOriginDict    : Set g_DataOriginDict = Nothing
private g_systemConnected : g_systemConnected = False	' used to ensure we don't disconnect the system advise loops at the wrong time
private g_TestMeasurementError : g_TestMeasurementError = 0	' used to test this measurement script by reading debug flag for errors code.
private g_measurementPhase : g_measurementPhase = WIREEXPERIMENT2Lib.mpPreMeasurement

private g_pluginPreMmtManager : set g_pluginPreMmtManager = Nothing
private g_pluginInitMmtManager : set g_pluginInitMmtManager = Nothing
private g_pluginPostMmtManager : set g_pluginPostMmtManager = Nothing
private g_pluginFinalMmtManager : set g_pluginFinalMmtManager = Nothing

private g_preMmtPlugInConnected : g_preMmtPlugInConnected = False
private g_initMmtPlugInConnected : g_initMmtPlugInConnected = False
private g_postMmtPlugInConnected : g_postMmtPlugInConnected = False
private g_finalMmtPluginConnected : g_finalMmtPluginConnected = False
private g_doorOpenWarningIgnored : g_doorOpenWarningIgnored = False

private g_runningPlugIns : g_runningPlugIns = false

' -------------------------------------------------------------------------
' Main --
'    This is the entry point for running the whole measurement script. 
'    If you need to debug a measurement by running it without all the error
'    catching, you should either edit this function, or set the debugMeasurement
'    measurement property. eg By evaluating this:
'      Application.Measurement.Properties("debugMeasurement") = True
Public Function Main()
    g_sDataCollectMessage = "%nThe system is about to collect data.%nPlease ensure that the laser is on the sample and then select OK to continue.%n"
    g_sImageCollectMessage = "%nThe system is about to collect a video image of the sample.%nPlease check that the sample is visible in the video and then select OK to continue.%n"

    On Error Resume Next
        g_bDebugMeasurement = CBool(Measurement.Properties("debugMeasurement"))
        g_parentHWND = CLng(Measurement.Properties("HWND"))
        Dim oShell : Set oShell = CreateObject("WScript.Shell")
        ' Read "TestMeasurementScriptError" debug flag from the registry.
        g_TestMeasurementError = oShell.RegRead("HKLM\Software\Renishaw\WiRE2\Debug\TestMeasurementScriptError")
        'MsgBox "TestMeasurementScriptError = " &amp; CStr(g_TestMeasurementError)
    On Error Goto 0

    ' if we cannot overwrite/delete the target filename then 
    '   exit straight away before we try to write stuff into the wdf file 
    '   and corrupt an existing file...
    if (Measurement.DataSaveMode &lt;&gt; WIREEXPERIMENT2Lib.dsmIncrement) then
        if (DeleteExistingFile(Measurement.DataSaveFile) = false) then 
            MsgBox "Failed to delete the target Wdf file:" &amp; vbNewLine &amp; CStr(Measurement.DataSaveFile) &amp; vbNewLine &amp;  vbNewLine &amp; _
                    "Please set the measurement to save to a different filename and then try again.", _
                    vbOKOnly + vbCritical + vbSystemModal, FormatMessage("WiRE Measurement")
            Set Main = Nothing
            Exit Function
        End If
    End If

    If g_bDebugMeasurement Then
        Set Main = DebugMain
    Else
        Set Main = StandardMain
    End If

    If Not (g_pluginPreMmtManager is Nothing) Then
        g_pluginPreMmtManager.Cleanup
        Set g_pluginPreMmtManager = Nothing
    End If
    If Not (g_pluginInitMmtManager is Nothing) Then
        g_pluginInitMmtManager.Cleanup
        Set g_pluginInitMmtManager = Nothing
    End If

    If Not (g_pluginPostMmtManager is Nothing) Then
        g_pluginPostMmtManager.Cleanup
        Set g_pluginPostMmtManager = Nothing
    End If

    If Not (g_pluginFinalMmtManager is Nothing) Then
        g_pluginFinalMmtManager.Cleanup
        Set g_pluginFinalMmtManager = Nothing
    End If

End Function

private sub ConnectSystem
    if g_systemConnected = false then
        ConnectObject System, "System_"
        g_systemConnected = true
        if Not (Logger Is Nothing) then Logger.Log " measurement: connected System ++ "
    end if
end sub

private sub DisconnectSystem
    if g_systemConnected = true then
        DisconnectObject System
        g_systemConnected = false
        if Not (Logger Is Nothing) then Logger.Log " measurement: disconnected System -- "
    end if
end sub

Private Sub ConnectPlugInManagers
    If g_preMmtPluginConnected = False Then
        ConnectObject g_pluginPreMmtManager, "PlugIn_"
        g_preMmtPlugInConnected = True
        if Not (Logger Is Nothing) then Logger.Log " measurement: connected pre mmt plug-in ++ "
    End If

    If g_initMmtPlugInConnected = False Then
        ConnectObject g_pluginInitMmtManager, "PlugIn_"
        g_initMmtPlugInConnected = True
        if Not (Logger Is Nothing) then Logger.Log " measurement: connected init mmt plug-in ++ "
    End If
    
    If g_postMmtPlugInConnected = False Then
        ConnectObject g_pluginPostMmtManager, "PlugIn_"
        g_postMmtPlugInConnected = True
        if Not (Logger Is Nothing) then Logger.Log " measurement: connected post mmt plug-in ++ "
    End If

    If g_finalMmtPluginConnected = False Then
        ConnectObject g_pluginFinalMmtManager, "PlugIn_"
        g_finalMmtPlugInConnected = True
        if Not (Logger Is Nothing) then Logger.Log " measurement: connected final mmt plug-in ++ "
    End if
End Sub

Private Sub DisconnectPlugInManagers
    If g_preMmtPlugInConnected = True Then
        DisconnectObject g_pluginPreMmtManager
        g_preMmtPlugInConnected = False
        if Not (Logger Is Nothing) then Logger.Log " measurement: disconnected pre mmt plug-in -- "
    End If

    If g_initMmtPlugInConnected = True Then
        DisconnectObject g_pluginInitMmtManager
        g_initMmtPlugInConnected = False
        if Not (Logger Is Nothing) then Logger.Log " measurement: disconnected init mmt plug-in -- "
    End If

    If g_postMmtPlugInConnected = True Then
        DisconnectObject g_pluginPostMmtManager
        g_postMmtPlugInConnected = False
        if Not (Logger Is Nothing) then Logger.Log " measurement: disconnected post mmt plug-in -- "
    End If

    If g_finalMmtPlugInConnected = True Then
        DisconnectObject g_pluginFinalMmtManager
        g_finalMmtPlugInConnected = False
        if Not (Logger Is Nothing) then Logger.Log " measurement: disconnected final mmt plug-in -- "
    End If
End Sub

' -------------------------------------------------------------------------
' This main function doesn't catch errors. This means that the Designer
' can identify the real location of an error in your script and display the
' location of the error.
'
Public Function DebugMain()
    Set Logger = New CLogger
    Logger.Log "Starting Debugging Acquisition Measurement " &amp; s_Version
    Activity FormatMessage("Starting Debugging Acquisition Measurement %1", s_Version)
    g_bDebugMeasurement = True
    CommonMain
    
    '
    ' the below block disconnects the plugin manager. Will an error here prevent the DebugMain from returning the Measurement.WdfResultSpectrums ?
    '
    ConnectPlugInManagers
    ConnectSystem
    Dim pluginResult
    pluginResult = RunPlugInManager(g_pluginFinalMmtManager)
    DisconnectPlugInManagers
    DisconnectSystem
    '
    ' END of disconnect plugin manager block.
    '
    
    Dim oFSO : Set oFSO = CreateObject("Scripting.FileSystemObject")
    if Not (Measurement is Nothing) And (oFSO.FileExists(Measurement.DataSaveFile)) then
        Set DebugMain = Measurement.WdfResultSpectrums
    Else
        Set DebugMain = Nothing
    End If
End Function

' -------------------------------------------------------------------------
' Full error handling main. Any errors occurring in the script are caught
' and returned as Error elements in the result memory file.
'
Private Function StandardMain()
    Set Logger = New CLogger
    Dim sMsg
    Logger.Log "Starting Standard Acquisition Measurement " &amp; s_Version
    Activity FormatMessage("Starting Standard Acquisition Measurement %1", s_Version)

    Measurement.WdfProperties("WiREData").Add "ScanCompletionStatus", "Incomplete"
    Measurement.WdfProperties("WiREData").Add "lastScanCompletionStatus","Incomplete"
    Measurement.WdfProperties("WiREData").Add "abortState", eWAS_OK
    On Error Resume Next

        Dim bRestoreInstrumentState : bRestoreInstrumentState = False
        Dim bCloseLaserShutter      : bCloseLaserShutter = False
        Dim bCycling                : bCycling = False
        Dim oShell : Set oShell = CreateObject("WScript.Shell")
        ' Read the old values then overwrite with new value -- makes us tolerant of being run on old systems.
        bRestoreInstrumentState = oShell.RegRead("HKCU\Software\Renishaw\Renishaw WiRE 2.0\Settings\MeasurementRestoreState")
        bRestoreInstrumentState = oShell.RegRead("HKCU\Software\Renishaw\WiREInterface.exe\Settings\MeasurementRestoreState")
        bCloseLaserShutter = oShell.RegRead("HKCU\Software\Renishaw\Renishaw WiRE 2.0\Settings\MeasurementCloseShutter")
        bCloseLaserShutter = oShell.RegRead("HKCU\Software\Renishaw\WiREInterface.exe\Settings\MeasurementCloseShutter")
        bCycling = CBool(Measurement.Properties("cycling"))

        ' override registry settings with local settings (may not be present)
        bRestoreInstrumentState = CBool(Measurement.Properties("restoreInstrumentState"))
        bCloseLaserShutter = CBool(Measurement.Properties("closeLaserShutter"))

        Activity FormatMessage("Recording initial instrument state")
        Set g_oInitialState = CreateObject("Renishaw.WiREInstStateCom")
        g_oInitialState.System = System
        g_oInitialState.InitialiseFromSystem

        Err.Clear
        CommonMain

        ' back up the error information so that we can report it after the PostCommonMain if needs be
        Dim errNumber : errNumber = Err.number
        Dim errSource : errSource = Err.Source
        Dim errDescription : errDescription = Err.Description
        
        Err.Clear
        PostCommonMain bRestoreInstrumentState, bCloseLaserShutter
        If Err.Number &lt;&gt; 0 Then
            ' log the error
            Logger.Error "Error in PostCommonMain: " &amp; CStr(Err.Number) &amp; ": src " &amp; Err.Source &amp; " : " &amp; Err.Description
            If errNumber = 0 Then   ' if we didn't have a previous error then return the error from PostCommonMain
                errNumber = Err.Number
                errSource = Err.Source
                errDescription = Err.Description
            Else
                ' append the PostCommonMain error onto the original error.
                errDescription = errDescription &amp; vbNewline &amp; Err.Source &amp; ": " &amp; vbNewline &amp; Err.Description
            End If
        End If

    On Error Goto 0
    
    If errNumber &lt;&gt; 0 Then
        ' record the error information from CommonMain before we do any clean-up work
        Logger.Error "Error in commonMain: src " &amp; errSource &amp; " : " &amp; errDescription
        UpdateResultErrors errNumber, errDescription, errSource

        ' error clean up added to fix bug 2614 (probably caused when the MSO
        '   was moved down into the Acquisition.
        If Not Acquisition.MSO Is Nothing Then
            Set Acquisition.MSO = Nothing
        End If
    End If

    Set g_oInitialState = Nothing
    Set g_DataOriginDict = Nothing

    if Not (Acquisition Is Nothing) then 
        If Acquisition.IsTimedOut then
            Err.Raise vbObjectError + 1, "Main", "The measurement timed out"
        End If
    End If

    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
    if Not (Measurement is Nothing) And (oFSO.FileExists(Measurement.DataSaveFile)) then
        Set StandardMain = Measurement.WdfResultSpectrums
    Else
        Set StandardMain = Nothing
    End If
End Function


Private Sub PostCommonMain(bRestoreInstrumentState, bCloseLaserShutter)
    If bRestoreInstrumentState Then
        ConnectSystem
        RestoreInitialInstrumentState bCloseLaserShutter
        DisconnectSystem
    ElseIf bCloseLaserShutter Then
        ConnectSystem
        Set Instrument = New CInstrument
        InstrumentState.ShutterOpen = False
        Instrument.Init InstrumentState, System, g_doorOpenWarningIgnored
        Instrument.ApplyLampsAndMotors
        DisconnectSystem
        Set Instrument = Nothing
    End If
    ConnectPlugInManagers
    ConnectSystem
    Dim pluginResult
    pluginResult = RunPlugInManager(g_pluginFinalMmtManager)
    Select Case pluginResult
        Case ePlugInResult_Error:
            Err.Raise WIREFILEHANDLERLib.ePLUGIN_FAILED, "CommonMain", g_pluginFinalMmtManager.LastError
    End Select

    DisconnectPlugInManagers
    DisconnectSystem
End Sub

' if the measurement's file already existed then
'   this fn will delete the file and record that 
'   it already existed.
' Always returns TRUE unless there was an existing file AND
'   this fn failed to delete it.
Private function DeleteExistingFile(sFile)
    DeleteExistingFile = true
    If Len(sFile) &gt; 0 Then
        Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
        If oFSO.FileExists(sFile) then 
            on error resume next
            oFSO.DeleteFile sFile
            if err.number &lt;&gt; 0 then
                DeleteExistingFile = false	' record the failure.
            End if
        End If
    End If
End function


' Apply the initial instrument state and optionally force the laser shutter closed
Private Sub RestoreInitialInstrumentState(bForceCloseLaserShutter)
    If Not(g_oInitialState Is Nothing) Then
        Activity FormatMessage("Restoring initial instrument state")
        If bForceCloseLaserShutter Then g_oInitialState.ShutterOpen = False
        Set Instrument = New CInstrument
        Instrument.Init g_oInitialState, System, g_doorOpenWarningIgnored
        Logger.Log "RestoreInitialInstrumentState running..."
        Instrument.ApplyLampsAndMotors
        Set Instrument = Nothing
    End If
End Sub

Private Sub InitialisePlugInManagers
    Dim oPlugInAccessor : Set oPlugInAccessor = CreateObject("Renishaw.WiREMmtPlugInAccessorCom")
    Dim oPlugInManager : Set oPlugInManager = oPlugInAccessor.GlobalTypeManager
    Dim outputFolder : outputFolder = oPlugInAccessor.ActiveOutputFolder

    Set g_pluginPreMmtManager = CreateObject("Renishaw.WiREMmtPlugInRuntimeCom")
    g_pluginPreMmtManager.Initialise System, outputFolder, g_parentHWND
    g_pluginPreMmtManager.LoadFromExperiment Measurement, oPlugInManager, ePlugInOperation_Pre

    Set g_pluginInitMmtManager = CreateObject("Renishaw.WiREMmtPlugInRuntimeCom")
    g_pluginInitMmtManager.Initialise System, outputFolder, g_parentHWND
    g_pluginInitMmtManager.LoadFromExperiment Measurement, oPlugInManager, ePlugInOperation_Init

    Set g_pluginPostMmtManager = CreateObject("Renishaw.WiREMmtPlugInRuntimeCom")
    g_pluginPostMmtManager.Initialise System, outputFolder, g_parentHWND
    g_pluginPostMmtManager.LoadFromExperiment Measurement, oPlugInManager, ePlugInOperation_Post

    Set g_pluginFinalMmtManager = CreateObject("Renishaw.WiREMmtPlugInRuntimeCom")
    g_pluginFinalMmtManager.Initialise System, outputFolder, g_parentHWND
    g_pluginFinalMmtManager.LoadFromExperiment Measurement, oPlugInManager, ePlugInOperation_Final
    Set oPlugInAccessor =  Nothing
    Set oPlugInManager = Nothing
End Sub

Private Function RunPlugInManager(oMgr)
	Dim oInstrument : Set oInstrument = new CInstrument
    oInstrument.Init InstrumentState, System, g_doorOpenWarningIgnored
    g_runningPlugIns = true
    RunPlugInManager = oMgr.Run
    g_runningPlugIns = false
    oInstrument.WaitForIdleSystem System, 250, "RunPlugInManager - post run"
    Set oInstrument = Nothing
End Function

Private Function CommonMain()
    ' pass the parent's HWND to the System
    if g_parentHWND &lt;&gt; 0 then 
        System.ParentHWND = g_parentHWND
        InstrumentState.ParentHWND = g_parentHWND
        Logger.Log "Setting the parent HWND to " &amp; CStr(g_parentHWND)
    end if
    InitialisePlugInManagers
    ConnectPlugInManagers
    ConnectSystem

    Dim pluginResult
    pluginResult = RunPlugInManager(g_pluginPreMmtManager)

    Select Case pluginResult
        Case ePlugInResult_Aborted:
		    Logger.Error "Measurement aborted - disconnecting system and plugins"
            DisconnectSystem
            DisconnectPlugInManagers
            Exit Function
        Case ePlugInResult_Error:
            Err.Raise WIREFILEHANDLERLib.ePLUGIN_FAILED, "CommonMain", g_pluginPreMmtManager.LastError
    End Select

    g_measurementPhase = WIREEXPERIMENT2Lib.mpMeasurement

    ' busy lamp removed to allow access from CAcquisition class
    Dim oBusyLamp : Set oBusyLamp = New CAutoMultiSequenceOperation
    Set oBusyLamp.System = System
    oBusyLamp.Name = "Measurement"
    oBusyLamp.Start

    dim errSrc, errNumber, errDescription
    dim bErrorHasOccured: bErrorHasOccured=false

    On Error Resume Next    ' suppress error throwing so that we can cleanly terminate the oBusyLamp and the Acquisition 

    ' CommonMain_internal_preCreateAcquisition fires the RaiseMeasurementInitialised event which MUST be fired before the
    '   Acquisition object is created because CAP and MicroplateMapping use the event to pass in initialisation parameters.
    CommonMain_internal_preCreateAcquisition
    If Err.Number &lt;&gt; 0 Then
        errDescription = Err.Description
        errNumber = Err.Number
        errSrc = Err.Source
        bErrorHasOccured = true
    Else
        Set Acquisition = New CAcquisition
        If Err.Number &lt;&gt; 0 Then
            errDescription = Err.Description
            errNumber = Err.Number
            errSrc = Err.Source
            bErrorHasOccured = true
        End If
    End If

    If bErrorHasOccured = false Then
        Set Acquisition.MSO = oBusyLamp

        ' run the internal CommonMain here, catching any errors. Then 
        '    close off the objects (allows MSO to complete if an error occurs)
        CommonMain_internal oBusyLamp
        If Err.Number &lt;&gt; 0 Then
            errDescription = Err.Description
            errNumber = Err.Number
            errSrc = Err.Source
            bErrorHasOccured = true
        End If
        Set Acquisition.MSO = Nothing
    End If

    On Error Goto 0     ' now allow the throwing of errors again
    
    ' we must close off the MSO and the tms stage before raising the errors.
    Set oBusyLamp = Nothing

    DisconnectSystem
    DisconnectPlugInManagers

    If bErrorHasOccured Then
        Logger.Log "CommonMain had an error: raising it. Number=" &amp; CStr(errNumber)  &amp; ", Src=" &amp; CStr(errSrc) &amp; ", Desc=" &amp; CStr(errDescription)
        Err.Raise errNumber, errSrc, errDescription
    End If

    Activity FormatMessage("Completed")
    Logger.Log "Standard Acquisition Measurement Completed."

    Dim oFSO : Set oFSO = CreateObject("Scripting.FileSystemObject")
    if Not (Measurement is Nothing) And (oFSO.FileExists(Measurement.DataSaveFile)) then
        g_pluginPreMmtManager.StoreResults(Measurement.DataSaveFile)
        g_pluginPostMmtManager.StoreResults(Measurement.DataSaveFile)
    End if
	
    if Not (Measurement is Nothing) And (oFSO.FileExists(Measurement.DataSaveFile)) then
        Set CommonMain = Measurement.WdfResultSpectrums
    Else
        Set CommonMain = Nothing
    End If
End Function

Private sub CommonMain_internal_preCreateAcquisition()
    ' Initialize the Acquisition data and run
    Activity FormatMessage("Initializing: Test Area Key")
    g_AbortReqCount = 0 ' reset the abort request count.

    ' Check the instrument state object
    Dim vAreaKeyTest: vAreaKeyTest = System.TestAreaKey (InstrumentState.AreaKey)

    if CStr(vAreaKeyTest) &lt;&gt; "0" then
        Err.Raise vbObjectError + 1, "CommonMain", vAreaKeyTest
    end if

    'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
    if (g_TestMeasurementError = 100) then  Err.Raise vbObjectError + 1, "CommanMain", "Test error 100 raised at the start of the CommanMain"
    ' Raise the Measurement initialised event.
    Activity FormatMessage("Initializing: RaiseMeasurementInitialised")
    Measurement.RaiseMeasurementInitialised
End Sub

Private Sub CommonMain_internal(oBusyLamp)
    ' Use the internal Acquisition object and perform basic sanity checking.
    On Error Goto 0
    Activity FormatMessage("Initializing %1 measurement", Acquisition.AcquisitionTypeName)
    Dim sMmtType : sMmtType = Measurement.Properties("MeasurementType")
    Dim aMmtType : aMmtType = Split(sMmtType, " ")
    On Error Resume Next
        sMmtType = aMmtType(0)
    On Error Goto 0
    If sMmtType &lt;&gt; Acquisition.AcquisitionTypeName Then
        Logger.Warn "Measurement type string do not match! (" &amp; sMmtType _
          &amp; " != " &amp; Acquisition.AcquisitionTypeName &amp; ")"
    End If

    'Acquisition.Init System, Scan, Measurement
    ' Connect to the system for events
    Activity FormatMessage("Initializing: Connect to system")
    Scan.System = System

    ' Use the instrument state area key
    Scan.AreaKey = InstrumentState.AreaKey

    ' If we have a mapping-on-the-fly specification, apply it now.
    Dim oMapSpec : Set oMapSpec = Nothing
    On Error Resume Next
        Set oMapSpec = Measurement.NamedItems("MappingSpecification")
        If Not (oMapSpec Is Nothing) Then
            Set Scan.MappingSpecification = oMapSpec
        End If
    On Error Goto 0
    
    'ensure that the instrument is in the correct areakey so that the grating and calibration 
    'parameters are correct.
    Set Instrument = New CInstrument
    Instrument.Init InstrumentState, System, g_doorOpenWarningIgnored ' copy over our required instrument state parameters

    ' If we're doing external signal mapping, tell the scan here
    Dim bUseExternalMapping : bUseExternalMapping = False
    On Error Resume Next
        bUseExternalMapping = Measurement.Properties("useExternalSignalMapping")
    On Error Goto 0
	Scan.UseExternalsignalMapping = bUseExternalMapping
    Logger.Log "Measurement setting external signal mapping to " &amp; CStr(bUseExternalMapping)

    ' ensure we use the correct LiveTrack path in the Podule if the measurement is using LiveTrack
    Dim bUsePAF : bUsePAF = False
    On Error Resume Next
        bUsePAF = Measurement.Properties("PAFEnabled")
    On Error Goto 0 
    Logger.Log "Measurement setting use of LiveTrack to " &amp; CStr(bUsePAF)

    ' set the podule path for LiveTrack if required.
    Instrument.ModPodulePathForLiveTrack bUsePAF

    Instrument.ApplyAreaKey                 ' and apply the specified areakey.
    Set Instrument = Nothing

    ' read the cycling flag
    Dim bCycling : bCycling = False
    On Error Resume Next
        bCycling = CBool(Measurement.Properties("cycling"))
    On Error Goto 0

    Dim pluginResult
    pluginResult = RunPlugInManager(g_pluginInitMmtManager)

    Select Case pluginResult
        Case ePlugInResult_Aborted:
            Logger.Error "init plugins aborted"
            Exit Sub
        Case ePlugInResult_Error:
            Err.Raise WIREFILEHANDLERLib.ePLUGIN_FAILED, "CommonMain", g_pluginInitMmtManager.LastError
    End Select
    ' Move the grating to the correct region to avoid potential timeouts
   
    InitializeGrating
    
    ' This is a good place to call one-off measurement initializations for user-modified measurements.
    ' MoveToOrigin
    MoveToFixedZPosition

    ' Initialize the Response Calibration
     Dim bUseCalibration : bUseCalibration = False
     On Error Resume Next
        bUseCalibration = Measurement.Properties("responseCalibration")
     On Error Goto 0
     Scan.UseResponseCal = bUseCalibration

    ' Tell the scan whether it is using PAF
    Scan.UsePAF = bUsePAF ' if using PAF, this blocks until it's connected 

    ' Before setting instrument state, should stop PAF tracking (if it's already tracking)
    If Scan.UsePAF Then
        Logger.Log "Measurement calling StopPAFTracking before aplying InstrumentState..."
        Scan.StopPAFTracking False ' False means PAF won't close after stopping 
    End If 

    ' Apply the instrument state - this sets the following in order
    'applies the areakey
    'then podule motors, beam expander, pinhole, waveplates, NDs, 
    'and then the laser shutter.
    Set Instrument = New CInstrument
    Instrument.Init InstrumentState, System, g_doorOpenWarningIgnored
    ' set the podule path for LiveTrack if required.
    Instrument.ModPodulePathForLiveTrack bUsePAF

    ' set the podule path to external or internal depending on the microscope
    ModPodulePathForMicroscope InstrumentState, System
    
    dim oILock: Set oILock = System.HostedObject(eSHO_INTERLOCK) 
    dim bInterlockAtStart: bInterlockAtStart = oILock.InterlockStatus(0)    ' 0 is eILC_INTERLOCK
    dim interlockRelaysAtStart: interlockRelaysAtStart = oILock.RefreshRelayState
         
    dim shutterPos: shutterPos = InstrumentState.ShutterOpen       ' store the shutter open in case we want to force it closed
    
    ' check to see if the measurement is accidentally being run with no laser
    if (InstrumentState.RunSilent = true AND _
        oILock.InterlockChainClosed = false AND _
        InstrumentState.ShutterOpen = true) then
        Measurement.WdfProperties("WiREData").Add "InterlockPreventedOpeningOfShutter", true
    end if

    if (Acquisition.MinimizeLaserShutter() = true And bCycling = False) then 
    ' in temp series mmts, there might be a long delay before the first acq so 
    '  we should start with the laser shutter closed.
        InstrumentState.ShutterOpen = false
    end if
    If Acquisition.MaximizeWhitelight Then
        Instrument.ApplyAllWhitelight Acquisition.ImageCapture.IlluminationLampBrightness
    ElseIf Acquisition.ImageCaptureBeforeDataCollection then
        ' this prevents the podule being driven to the wrong position if
        'an image is to be captured before data collection.
        ' The downside of this is that the recorded inst state will not reflect the
        'data collection state, but the image capture state.
        Instrument.ApplyForImageCapture Acquisition.ImageCapture.IlluminationLampOn, Acquisition.ImageCapture.IlluminationLampBrightness
    Else
        Instrument.Apply
        Logger.Log "Measurement applied instrument state"
    End If
    InstrumentState.ShutterOpen = shutterPos    ' restore the laserShutter state to what it should be.
    Instrument.Record
    ' record the lightpath string into the instrumentState's dictionary.
    if System.InstrumentType = eWIT_RA802 then
        Logger.Log "Adding Lightpath '" + InstrumentState.Lightpath + "' into the snapshot of the instrumentState"
        Instrument.InstrumentState.Add "Lightpath", InstrumentState.Lightpath
    end if
    g_nUpdates = 0

	' This is where we can set PAF's targets, but not start tracking yet.
	' We only want to set targets for inVia, not RA802.
	' For now this is done with a temporary debug flag.
'	If Scan.UsePAF Then	
'		Logger.Log "Measurement setting PAF targets (if inVia)"
'		Dim oShell : Set oShell = CreateObject("WScript.Shell")
'			On Error Resume Next
'			If oShell.RegRead("HKEY_LOCAL_MACHINE\SOFTWARE\Renishaw\WiRE2\Debug\IsInVia") = 1 Then
'				Scan.SetPAFTargets			
'			End If
'			'if the reg key did not exist then the errorNumber will be set: assume it is an inVia
'			If Err.Number &lt;&gt; 0 Then Scan.SetPAFTargets
'			On Error GoTo 0
'	End If 

    'Set the recorded instrument and calibration states into measurement.
    Measurement.CalibrationState = Instrument.CalibrationState
    Measurement.InstrumentState = Instrument.InstrumentState

    ' Store the version of WiRE used to run this measurement
    On Error Resume Next
        Dim oSHO : Set oSHO = System.HostedObject(WIRESYSTEMLib.eSHO_PROPERTIES)
        g_bUseCollectWarning = CBool(oSHO.Item("MeasurementCollectWarningEnabled"))
    On Error Goto 0

    ' Store the firmware version number of the CCD on which this measurement is run.
    On Error Resume Next
    Dim oFWVersion: Set oFWVersion = System.HostedObject(WIRESYSTEMLib.eSHO_CAMERA_VERSION)
    If oFWVersion.Emulating then
        Measurement.WdfProperties("WiREData").Add "CCD emulating",true
    Else
        Measurement.WdfProperties("WiREData").Add "CCD not emulating",true
    End if

    Measurement.WdfProperties("WiREData").Add "CCD serial number", oFWVersion.serialNumber
    Measurement.WdfProperties("WiREData").Add "CCD firmware version", oFWVersion.firmwareVersion
    If oFWVersion.firmwareVersionMajor = 4 then
        Measurement.WdfProperties("WiREData").Add "CCD SYSID", oFWVersion.CentrusSYSID
    Else
        Measurement.WdfProperties("WiREData").Add "CCD plm version", oFWVersion.plmVersion
    End if

    On Error Goto 0

    ' Set the estimated completion time and status elements
    Measurement.Properties("ETA") = DateAdd("s", TimeToComplete(), UTCNow())
    
    ' Setup the result data file parameters for this measurement type
    Set g_DataOriginDict = CreateObject("Renishaw.WiREDictionaryCom")
    Dim dataOriginIndex : dataOriginIndex = 0
    'Dim alternateOriginIndex: alternateOriginIndex = 0
    
    On Error Resume Next
    'Check if it is a multi position CAP measurement or microplate mapping measurement
    Dim bCAPSeries : bCAPSeries = false
    Dim bMicroplatemapping : bMicroplatemapping = false
    if(Acquisition.AcqMode = eCustomSeries) then
        Dim oCAPPresent : Set oCAPPresent = Nothing
        Set oCAPPresent = Measurement.NamedItems("CAP")
        If Not (oCAPPresent Is Nothing) Then
            bCAPSeries = true
            Set oCAPPresent = Nothing
        End If

        Dim oMicroplateMap : Set oMicroplateMap = Nothing
        Set oMicroplateMap = Measurement.NamedItems("MicroplateDefinition")
        If Not (oMicroplateMap Is Nothing) Then
            bMicroplatemapping = true
            Set oMicroplateMap = Nothing
        End If
    End If

    On Error Goto 0
    ' Are we using X and Y positions?
    If ((Acquisition.AcqType AND eXYArea) = eXYArea) OR bCAPSeries OR bMicroplatemapping Then
        AddOriginInfo dataOriginIndex,WIREFILEHANDLERLib.eX_SPATIAL, WIREFILEHANDLERLib.eMICROMETRES, "X",false   '"X / µm"
        dataOriginIndex = dataOriginIndex + 1
        AddOriginInfo dataOriginIndex,WIREFILEHANDLERLib.eY_SPATIAL, WIREFILEHANDLERLib.eMICROMETRES, "Y",false    '"Y / µm"
        dataOriginIndex = dataOriginIndex + 1       
    End If
    
    ' Are we using Z (depth) positions?
    If ((Acquisition.AcqType AND (eDepths Or eSurface)) &lt;&gt; 0) OR bCAPSeries Then
        AddOriginInfo dataOriginIndex , WIREFILEHANDLERLib.eZ_SPATIAL, WIREFILEHANDLERLib.eMICROMETRES, "Z",false '"Z / µm"
        dataOriginIndex = dataOriginIndex + 1
    elseif bMicroplatemapping then
        AddOriginInfo dataOriginIndex , WIREFILEHANDLERLib.eZ_SPATIAL, WIREFILEHANDLERLib.eMICROMETRES, "Z", true '"Z / µm"
        dataOriginIndex = dataOriginIndex + 1
    End If

    ' Are we using Timing?
    'If (Acquisition.AcqType AND eTiming) = eTiming Then
        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eTIME, WIREFILEHANDLERLib.eFILETIME, "Time",false   '"Elapsed Time / s"
        dataOriginIndex = dataOriginIndex + 1
    'End If

    ' Are we using Temperature?     'eTharmal acqtype is obsolete for WiRE4
'    If (Acquisition.AcqType AND eThermal) = eThermal Then
'        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eTEMPERATURE, WIREFILEHANDLERLib.eKELVIN, "Temperature",false  '"Temperature / K"
'        dataOriginIndex = dataOriginIndex + 1
'    End If

    'If Microplate mapping measurement then update below origins.
    If bMicroplatemapping then
        'LocationIndex-origin details...
        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eMP_LOCATIONINDEX, WIREFILEHANDLERLib.eARBITRARY_TYPE, "LocationIndex", True
        dataOriginIndex = dataOriginIndex + 1
        
        'WellReference-origin details...
        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eMP_WELLREFERENCE, WIREFILEHANDLERLib.eARBITRARY_TYPE, "WellReference", True
        dataOriginIndex = dataOriginIndex + 1
    End If

    'We can use same variable to keep count while adding data for alternative into dictionary.
    ' Are we a user-triggered series?
    If (Acquisition.AcqType AND eTriggeredSeries) = eTriggeredSeries then
'        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eTIME, WIREFILEHANDLERLib.eSECONDS, "Time",false   '"Elapsed Time / s"
'        dataOriginIndex = dataOriginIndex + 1
        dataOriginIndex = dataOriginIndex + 1
        AddOriginInfo dataOriginIndex,WIREFILEHANDLERLib.eTEMPERATURE, WIREFILEHANDLERLib.eCELCIUS, "Temperature",true  '"Temperature / °C"
        'alternateOriginIndex = alternateOriginIndex + 1
    elseif (Acquisition.AcqType AND eThermal2) = eThermal2 Then
'        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eTIME, WIREFILEHANDLERLib.eSECONDS, "Time",false    '"Elapsed Time / s"
        'dataOriginIndex = dataOriginIndex + 1 
        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eTEMPERATURE, WIREFILEHANDLERLib.eCELCIUS, "Temperature", false  '"Temperature / °C"
        'alternateOriginIndex = alternateOriginIndex + 1
        dataOriginIndex = dataOriginIndex + 1
        AddOriginInfo dataOriginIndex, WIREFILEHANDLERLib.eRAMPRATE, WIREFILEHANDLERLib.eKELVINPERMINUTE, "RampRate",true  '"Ramp rate / (°C/min)"
        dataOriginIndex = dataOriginIndex + 1
        'alternateOriginIndex = alternateOriginIndex + 1
    End If

    'Check if FocusTrack is Enabled and set the origin Params
    if Acquisition.FocusTrackEnabled then
        AddOriginInfo dataOriginIndex,WIREFILEHANDLERLib.eFOCUSTRACK, WIREFILEHANDLERLib.eMICROMETRES, "FocusTrack",true  '"µm"
        dataOriginIndex = dataOriginIndex + 1
        'alternateOriginIndex = alternateOriginIndex + 1
    End If
    
    g_DataOriginDict.Add "TotalOriginCount",dataOriginIndex '+ alternateOriginIndex)
    Measurement.WdfProperties.Add g_DataOriginDict,"OriginProps"         
    
    On Error Goto 0
    Dim collected :collected = -1
    Measurement.WdfProperties("WiREData").Add "InterlockOKStart", bInterlockAtStart
    Measurement.WdfProperties("WiREData").Add "InterlockRelaysStart", interlockRelaysAtStart
    Measurement.WdfProperties("WiREData").Add "InterlockChainAtEnd", oILock.interlockChainStatus
    Measurement.WdfProperties("WiREData").Add "InterlockPeripheralsAtEnd", oILock.interlockPeriphals
    Measurement.WdfProperties("WiREData").Add "InterlockOKEnd", false
    Measurement.WdfProperties("WiREData").Add "InterlockRelaysEnd", collected    
    Measurement.WdfProperties("WiREData").Add "UnsaturatedNDPercent", 0    
    Measurement.WdfProperties("WiREData").Add "UnsaturatedExposureTime", 0    
    Measurement.WdfProperties("WiREData").Add "SaturationProtectionUsed", false    
            
    On Error Resume Next

    ' Support cycling measurements.
    if bCycling then
        'To create file if not exist and check whether to increment or not...
       Acquisition.CheckDataSaveModeAndFile       
    End If 

   'Add MeasurementObject into measurement properties collection so as WiREScan can use it to write measurement block into file.
    Dim pDictMeasurementObject : Set pDictMeasurementObject = CreateObject("Renishaw.WiREDictionaryCom")
    Dim OMeasurementObj : Set OMeasurementObj  = Measurement
    pDictMeasurementObject.Add "Measurement",OMeasurementObj
    Measurement.WdfProperties.Add pDictMeasurementObject,"MeasurementObject"
    
    On Error Goto 0
    Dim bWasCycling : bWasCycling = bCycling
    Do
        If bCycling Then
            Acquisition.WaitForSystem 250    ' wait for the system to be idle. (#3819)
            MinimalDoScan
        Else
            'Run the measurement and In case there is any error occurred during measurement acquisition should be logged into file or in diagnostic.
            Acquisition.Run
            If Acquisition.AcqType = eThermal Then Acquisition.CheckFinalTemperature
            On Error Goto 0
        End If
        On Error Resume Next
            bCycling = CBool(Measurement.Properties("cycling"))
        On Error Goto 0
        If bCycling Then Activity FormatMessage("Cycling measurement")
    Loop While bCycling

    ' record the state of the interlock on completion.    
    dim bInterlockAtEnd: bInterlockAtEnd = oILock.InterlockStatus(0)    ' 0 is eILC_INTERLOCK
    dim interlockRelaysAtEnd: interlockRelaysAtEnd = oILock.RefreshRelayState
    
    ' record the interlock chain and peripheral info.
    '   this means that if the interlock is tripped at any stage, then
    '   client software can determine where the trip occurred.
    Dim oDictPostScanProps : Set oDictPostScanProps = CreateObject("Renishaw.WiREDictionaryCom")
    oDictPostScanProps.Add "InterlockChainAtEnd",oILock.interlockChainStatus
    oDictPostScanProps.Add "InterlockPeripheralsAtEnd",oILock.interlockPeriphals
    oDictPostScanProps.Add "InterlockOKEnd", bInterlockAtEnd
    oDictPostScanProps.Add  "InterlockRelaysEnd", interlockRelaysAtEnd
    'update lastScanCompletionStatus property only in case of measurement timed out
    'Otherwise it will be set from Scan.
    If Acquisition.IsTimedOut then
        oDictPostScanProps.Add  "lastScanCompletionStatus", Measurement.WdfProperties("WiREData").Item("lastScanCompletionStatus")    
    End If
    
    Acquisition.AddSaturationProtectionDetails oDictPostScanProps

    Activity FormatMessage("FinalizeWdfResult")
    FinalizeWdfResult oDictPostScanProps, bWasCycling

    'Release the objects by setting it to Nothing.
    Set oDictPostScanProps = Nothing
    Set Acquisition.TemperatureStage = Nothing
    pDictMeasurementObject.Remove "Measurement"
    Set pDictMeasurementObject = Nothing
    Set OMeasurementObj = Nothing

    g_measurementPhase = WIREEXPERIMENT2Lib.mpPostMeasurement

    ' release the Instrument object after the Acquisition object has completed.
    Set Instrument = Nothing

    Dim pluginPostResult
    If MmtAbortState = WIRESYSTEMLib.eWAS_OK Then ' do not overwrite existing entries
        pluginPostResult = RunPlugInManager(g_pluginPostMmtManager)
        Select Case pluginPostResult
            Case ePlugInResult_Error:
                Err.Raise WIREFILEHANDLERLib.ePLUGIN_FAILED, "CommonMain_internal", g_pluginPostMmtManager.LastError
        End Select
    end if

End sub
    
Private Function AddOriginInfo(nIndex,OriginType, OriginUnits, OriginName,bAlterNativeOrigin)
    g_DataOriginDict.Add "Type" &amp; CStr(nIndex),OriginType
    g_DataOriginDict.Add "Units" &amp; CStr(nIndex),OriginUnits
    g_DataOriginDict.Add "Label" &amp; CStr(nIndex),OriginName
    g_DataOriginDict.Add "IsAlternate" &amp; CStr(nIndex),bAlterNativeOrigin    
End Function

Private Function FinalizeWdfResult(oWdfResult, bWasCycling)
    ' Move the temporary status string over the official string
    If Not(bWasCycling) Then
    '    oWdfResult.Item("ScanCompletionStatus") = oWdfResult.Item("ScanCompletionStatus")
    End If

    'If measurement file doesn't exist then don't proceed
    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
    If Not (oFSO.FileExists(Measurement.DataSaveFile)) Then
        Logger.Warn "Exiting FinalizeWdfResult as file doesn't exist"
        exit function
    End If
    ' Clear up the activity trace elements
    On Error Resume Next

        Dim nCn : nCn = Measurement.Properties("AcquisitionCount")
        If nCn &lt;&gt; g_nScan Then Logger.Warning "AcquitionCount and g_nScan disagree!"
        Measurement.Properties("AcquisitionCount") = g_nScan
    On Error Goto 0
    
    

    ' bug #1963: Add CustomProperties items from the System.
    Dim oSysProps : Set oSysProps = System.HostedObject(WIRESYSTEMLib.eSHO_PROPERTIES)
    On Error Resume Next
        Dim oCustomProps : Set oCustomProps = oSysProps.Item("CustomProperties")
        If IsObject(oCustomProps) Then
            Dim vKey
            For Each vKey In oCustomProps.Keys
                oWdfResult.Item(CStr(vKey)) = oCustomProps.Item(vKey)
            Next
        End If
        'Update postscan properties into result file.
        Measurement.UpdatePostScanProperties oWdfResult
    ' move the on error goto 0 to below adding the NumberOfPoints to the Result.
    On Error Goto 0 ' Bug 3141 - On HF3077 scan error messages are lost

    Set FinalizeWdfResult = oWdfResult
End Function

' Update the result wdf file with any error information.
Private Sub UpdateResultErrors(nCode, sDescription, sSource)
    Logger.Log "UpdateResultErrors : log error into file in case of error."
    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
    If nCode &lt;&gt; 0 Then
        If Not (Measurement is Nothing) And (oFSO.FileExists(Measurement.DataSaveFile)) then
            Dim oDictErrProps : Set oDictErrProps = CreateObject("Renishaw.WiREDictionaryCom")
            oDictErrProps.Add "ErrorCode", nCode
            oDictErrProps.Add "ErrorSource", sSource
            oDictErrProps.Add "ErrorDescription", sDescription
            oDictErrProps.Add  "ScanCompletionStatus", "Failed"
            Measurement.UpdatePostScanProperties oDictErrProps
            Set oDictErrProps = Nothing
        End If

        Dim sErr : sErr = sSource &amp; ": " &amp; sDescription
        Logger.Error sErr : Activity sErr
        Err.Raise nCode, sSource, sDescription
    End If
End Sub

'
' -------------------------------------------------------------------------
'
' Handle scan events and waiting for scan complete. This minimal version is
' called when we are doing a cycling measurement. In this case we avoid the
' data manipulations involved in creating a properly formed measurement
' result.
'
Private g_bMinimalScanComplete
Private g_bMinimalScan : g_bMinimalScan = False

Public Function MinimalDoScan
    g_bMinimalScan = True
    g_bMinimalScanComplete = False
    On Error Resume Next
    Scan.MeasurementHandle = Measurement.Properties("queueHandle")
    Scan.DoScan3 System, g_parentHWND, Measurement.WdfProperties,0,-1,Measurement.DataSaveFile 
    
    'In case there is any error occurred during measurement acquisition should be logged into file or in diagnostic.
    UpdateResultErrors Err.Number, Err.Description, Err.Source    
    If Err.number &lt;&gt; 0 then
        Err.Raise Err.Number, Err.Source, Err.Description
    End If 
    
    MinimalWaitForScanComplete 1000, 480000
    g_bMinimalScan = False
End Function

Public Sub MinimalWaitForScanComplete(nCheckInterval, nMaxTimeout)
    Dim nTime : nTime = 0
    Do While Not(g_bMinimalScanComplete) And nTime &lt; nMaxTimeout
        Dim nWaited: nWaited = Sleep2(nCheckInterval)
        nTime = nTime + CLng(nWaited)
    Loop
    If Not(g_bMinimalScanComplete) Then
        Err.Raise vbObjectError + 1, "WaitForScanComplete", "Wait timeout"
    End If
End Sub

' -------------------------------------------------------------------------

Class CAcquisition
    Private m_eMode      ' Mode of use for the acquisition. Single scan, custom series, complete series or interupted series
    Private m_eType          ' type can be eSingle, eTiming, eDepthSeries
    Private m_nCount         ' the number of scans to perform in a series
    Private m_nInterval      ' the interval between scans in milliseconds or depth step size
    Private m_nInitialValue  ' the initial value for a series (if needed)
    Private m_nBleachTime    ' the number of milliseconds to laser bleach the sample.
    Private m_nScan          ' the number of the current scan
    Private m_dtSeriesStart  ' the time we began the first scan.
    Private m_dtScanStart    ' the time we started the current scan
    Private m_nAvgScanTime   ' the average elapsed real time taken for scans
    Private m_bScanComplete  ' flag set whenever a scan completes
    Private m_eTermination   ' copy of the scan termination status (ok, failed, aborted)
    Private m_bTimedOut      ' flag set true if a scan times out.
    Private m_oTStage        ' object wrapper for controlling a temperature stage
    Private m_oCameraWrapper ' additional camera status reporting object
    Private m_nMapPoints     ' size of the points array
    Private m_Point          ' the target point when using the XYZ stage
    Private m_nRate          ' set the rate of change for temperature or other dimensions
    Private m_nTSHoldms      ' the time in ms to pause at each temperature before collecting.
    Private m_bFocusTrackEnabled
    Private m_nFocusTrackInterval
    Private m_bFocusTrackComplete
    Private m_dFocalPoint    ' the last focus track focal position (or the current Z-position)
    Private m_aMapDepths     ' Depth slice depth positions.
    Private m_nMapDepths     ' Number of depth slice positions.
    Private m_sFocusTrackCompletionString
    Private m_eFocusTrackCompletionCode
    Private m_oScanResult    ' Temporary storage of the scan result so we can delay the sending of scan complete events
    Private m_nMapPointIndex ' Index into the map points array. 
    Private m_bHaltAfterScan ' to let the acquisition know that it should stop after the next scan
    Private m_bHaltAfterAcc  '
    Private m_bLineFocusMapping ' Is this  a linefocus mapping measurement?
    Private m_nLastUID       ' the last unique dataset number.
    Private m_oImageCapture  ' image capture object
    Private m_oMSO           ' the multi sequence operation object
    Private m_bSaturationMod            ' Saturation protection modification of the ND percent or exposure time
    Private m_bSaturated                ' Data saturation has been detected
    Private m_dSaturationNDPercent      ' ND value used for saturation avoidance
    Private m_lSaturationExpTime        ' Exposure time value used for saturation avoidance
    Private m_bMinimalShutter           ' Flag to control minimizing laser exposure on sample
    Private m_nTemperatureCount         ' Number of temperatures in the series
    Private m_nTimeSeriesCount          ' Number of collections in a time series
    Private m_LastDatasetCount          ' Number of items in the collected datasets collection after the previous scan.
    Private m_nTrueCount                ' Expected number of scans. Actually reflects the number of scans or fast mapping scans
    Private m_lastSave                  ' when the last save was done. Type VariantTime.
    Private m_bCollectTemperatureValues ' true if we should read the TMS temperature each scan
    Private m_bMaximizeWhitelight       ' true to switch to whitelight after every scan
    Private m_oTempRamps          ' Temperature ramps object
    Private m_bCollectTempProfile   ' Collect a temperature profile dataset, and add it into the result
    Private m_oTempDL            ' A datalist containing the temperatures
    Private m_oTimeDL            ' A datalist containing the times at which temperatures were read
    Private m_dExpTime          ' The scan exposure time last time we started the scan
    Private m_nAccs             ' The number of accumulations last time we started a scan
    Private m_dLaserPower       ' The laser power (ND percent) last time we started a scan
    Private m_sImagePath    ' File path of second white light image if present


    Public Property Get ScanCount() : ScanCount = m_nTrueCount: End Property
    Public Property Get MSO() : Set MSO = m_oMSO : End Property
    Public Property Set MSO(oMSO) : Set m_oMSO = oMSO : End Property
    Public Property Get TemperatureStage() : Set TemperatureStage = m_oTStage : End Property
    Public Property Set TemperatureStage(oTMS) : Set m_oTStage = oTMS : End Property
    Public Property Get HaltAfterScan(): HaltAfterScan = m_bHaltAfterScan : End Property
    Public Property Get HaltAfterAcc(): HaltAfterAcc = m_bHaltAfterAcc : End Property
    Public Property Get MaximizeWhitelight() : MaximizeWhitelight = m_bMaximizeWhitelight : End Property
    Public Property Get MinimizeLaserShutter() : MinimizeLaserShutter = m_bMinimalShutter : End Property
    Public Property Get ImageCapture() : Set ImageCapture = m_oImageCapture : End Property
    Public Property Get FocusTrackEnabled() : FocusTrackEnabled = m_bFocusTrackEnabled: End Property
    Public Property Set FocusTrackEnabled(bVal) : m_bFocusTrackEnabled = bVal: End Property    

    Private Sub Class_Initialize
        m_eMode = eSingle
        m_lastSave = 0
        m_nCount = 0
        m_nTrueCount = 0    '  Expected number of scans. Actually reflects the number of scans or fast mapping scans
        m_nInterval = 0
        m_eTermination = WIRESYSTEMLib.eWAS_OK
        m_bScanComplete = true
        m_bTimedOut = False
        m_bHaltAfterScan = False
        m_bHaltAfterAcc = False
        m_nInitialValue = 0
        m_eType = eSingle
        m_dFocalPoint = 0.0
        m_nRate = 10
        m_nTSHoldms=0    ' no hold time for temperature stage initially
        m_nAvgScanTime = 0
        m_nMapDepths = 0
        m_nMapPointIndex = 0
        m_nLastUID = 0
        m_nTemperatureCount = 0
        m_LastDatasetCount = 0
        m_bCollectTemperatureValues = False
        m_bMaximizeWhitelight = False
        ' m_sFocusTrackCompletionCode is reset in pre-scan
        Set m_oTStage = Nothing
        Set m_oCameraWrapper = Nothing
        Set m_oScanResult = Nothing
        Set m_oTempRamps = Nothing
        Set m_oImageCapture = New CImageCapture
        m_bMinimalShutter = False
        m_bCollectTempProfile = False
        Dim bCycling : bCycling = False

        On Error Resume Next
        m_nBleachTime = Measurement.Properties("BleachTime")
        m_sImagePath = Measurement.Properties("WhiteLight2")
        m_bFocusTrackEnabled = False
        m_bFocusTrackEnabled = Measurement.Properties("FocusTrackEnabled")
        m_nFocusTrackInterval = Measurement.Properties("FocusTrackInterval")
        m_bCollectTemperatureValues = Measurement.Properties("CollectTemperatureValues")
        m_bMaximizeWhitelight = Measurement.Properties("MaximizeWhitelight")
        bCycling = CBool(Measurement.Properties("cycling"))

        m_dExpTime = Scan.ExpTimeInMillSecs
        m_nAccs = Scan.NumOfAccumulations
        m_dLaserPower = InstrumentState.NDPercent
        System.ScanType = Scan.ScanType ' needed to identify between depthslice and streamlineHR depth slice.
        
        ' Check for custom series
        If m_eMode = eSingle Then
            Err.Clear
            m_nCount = Measurement.Properties("customScanCount")
            If Err.Number = 0 Then
                If m_nCount &gt; 1 Then
                    Scan.CustomLoopCount = m_nCount
                    m_eMode = eCustomSeries
                Else
                    m_nCount = 0
                End If
            End If
        End If

        If m_eMode = eSingle Then
            Err.Clear
            Dim bTriggered : bTriggered = False
            bTriggered = Measurement.Properties("UserTriggeredMeasurement")
            If bTriggered Then
                Logger.Debug "Setting acquisition type to eTriggered series"
                m_eMode = eInteruptedSeries
                m_eType = eTriggeredSeries
                m_nCount = Measurement.Properties("AcquisitionCount")                
                m_nTrueCount = m_nCount
                Scan.CustomLoopCount = m_nCount
            End If
        End If

        ' Check for area map
        If m_eMode = eSingle Then
            LogMessage "Searching for measurement configuration"
            m_nCount = 1
            Err.Clear
            ' Check for depth series
            m_nMapDepths = Measurement.Properties("DepthSeriesCount")
            If m_nMapDepths &lt;&gt; 0 Then 
                m_nInterval = Measurement.Properties("DepthSeriesInterval")
                m_nInitialValue = Measurement.Properties("DepthSeriesStartPos")
            End If

            Err.Clear
            Dim oMapArea : Set oMapArea = Measurement.NamedItems("MapArea")
            If m_nMapDepths &gt; 1 then
                if Err.Number &lt;&gt; 0 then
                    ' No map area object, but we want one for the depth series info
                    Err.Clear
                    Set oMapArea = CreateObject("Renishaw.WiREMapAreaCom")
                End If
                oMapArea.SetMappingDepths m_nInitialValue, m_nInterval, m_nMapDepths
            End If

            If Err.Number = 0 Then
                System.WiREMapArea = oMapArea
                Scan.MapArea = oMapArea
                ' The scan only uses the LinefocusStepSize variable if it is a rectangle map AND the linefocus flag is set.
                '   Interestingly the scan never uses the YCentrePixel passed in from this method.
                if Scan.AreaKey.FocusModeKey = eFOCUSMODE_LINEFOCUS OR Scan.AreaKey.FocusModeKey = eFOCUSMODE_STREAMLINE then
                    Scan.SetLinefocusParams GetLinefocusStepSize, CalculateYCenterPixel
                end if

                ' XY map
                m_eMode = eCompleteSeries
                m_nMapPoints = oMapArea.TotalPointsCount
                If m_nMapPoints &gt; 0 And Err.Number = 0 Then 
                    ' If we can do fast mapping then do it.
                    m_eType = m_eType OR eXYArea
                    m_nCount = m_nCount * m_nMapPoints
                End If

                Dim oSurface : Set oSurface = Nothing

                ' Map with Z info
                Err.Clear
                m_nMapDepths = oMapArea.GetAllMappingDepths(m_aMapDepths)
                ' If we say this is a depth map then it adds a Z data origin. The scan does not understand this for XY maps
                ' or streamline maps, because they would be volume maps, which we don't do.
                ' Therefore, don't say this is a depth map unless there is more than 1 depth.
                if m_nMapDepths &gt; 1 then
                    m_eType = m_eType OR eDepths
                    m_nCount = m_nCount * m_nMapDepths
                Else
                    Set oSurface = Measurement.NamedItems("SurfaceData")
                end if

                ' if we have a surface, but the system set up fails then abort the whole scan
                ' as we do not want to just run a point map anyway in case this result in collisions.
                On Error Goto 0
                System.SurfaceData = oSurface
                On Error Resume Next

                If Not (oSurface Is Nothing) Then
                    ' The System takes a copy of the surface data given to it and
                    ' updates the use surface flag if the current system state is
                    ' not configured for surfaces (e.g. an invalid objective).
                    Dim oUpdatedSurface : Set oUpdatedSurface = System.SurfaceData

                    Dim oUseSurface : oUseSurface = oUpdatedSurface.Item("UseSurface")
                    Dim oModel : Set oModel = oUpdatedSurface.Item("Surface")

                    If (Not (oUseSurface Is Nothing)) And (Not (oModel Is Nothing)) Then
                        If oUseSurface &lt;&gt; False And oModel.IsPlane = False Then
                            m_eType = m_eType Or eSurface
                        End If
                    End If
                End If
            End If
    
            ' Time info
            m_nTimeSeriesCount = Measurement.Properties("TimeSeriesCount")
            If m_nTimeSeriesCount &gt; 1 Then
                m_eType = m_eType OR eTiming
                m_nCount = m_nCount * m_nTimeSeriesCount
                If m_nMapDepths &gt; 1 Then m_nCount = m_nCount * m_nMapDepths
            End If

            Err.Clear
            If (m_nTimeSeriesCount &gt; 1 OR m_nBleachTime &gt; 0) Then
                Dim nTimeSeriesInterval : nTimeSeriesInterval = 0
                nTimeSeriesInterval = Measurement.Properties("TimeSeriesInterval")
                If Err.Number &lt;&gt; 0 Then
                    Logger.Warning "Failed to read TimeSeriesInterval for time series measurement. Using default value of 0"
                End If
                Scan.SetTimeSeriesInfo nTimeSeriesInterval, m_nTimeSeriesCount, m_nBleachTime
            End If

            ' Check for temperature series
            set m_oTempRamps = Measurement.Properties("TemperatureRamps")
            m_nTemperatureCount = Measurement.Properties("TemperatureSeriesCount")
            If IsObject(m_oTempRamps) And Not(m_oTempRamps Is Nothing) Then
                m_eType = eThermal2
                ' Set the expected number of collections to 2000 arbitrarily. For a more realistic, although still not 100%
                ' accurate, value, we could use the AcquisitionCount property instead, which is calculated from the ramp rate
                ' and hold intervals of the configured ramps and set in measurement by the wizard when it closes.
                m_nCount = 2000
                m_nRampID = 1
                Scan.CustomLoopCount = m_nCount
                m_eMode = eInteruptedSeries
                m_bCollectTempProfile = True
            ElseIf m_nTemperatureCount &gt; 1 Then
                m_eType = eThermal
                m_nCount = m_nCount * m_nTemperatureCount
                m_nInterval = Measurement.Properties("TemperatureSeriesInterval")
                m_nInitialValue = Measurement.Properties("TemperatureSeriesStart")
                m_nRate = Measurement.Properties("TemperatureSeriesRamp")
                m_nTSHoldms = Measurement.Properties("TemperatureSeriesHold")
                Scan.CustomLoopCount = m_nTemperatureCount
            End If

            m_nTrueCount = m_nCount
            Dim sInfo : sInfo = ""
            If (m_nTemperatureCount &gt; 1 Or m_bFocusTrackEnabled Or (m_bSaturationMod) _
            Or (m_oImageCapture.CaptureMode &lt;&gt; 0) Or m_eType = eThermal2 ) Then
                m_eMode = eInteruptedSeries
                sInfo = "Doing interrupted series of " &amp; CStr(m_nTrueCount) &amp; " scans." _
                    &amp; " Time: " &amp; CStr(m_nTimeSeriesCount) _
                    &amp; " Temp: " &amp; CStr(m_nTemperatureCount) _
                    &amp; " FT: " &amp; CBool(m_bFocusTrackEnabled) _
                    &amp; " Sat: " &amp; CBool(m_bSaturationMod) _
                    &amp; " Image: " &amp; CBool(m_oImageCapture.CaptureMode &lt;&gt; 0)
            Else
                m_nCount = 1
                m_eMode = eCompleteSeries
                sInfo = "Doing complete series of " &amp; CStr(m_nTrueCount) &amp; " scans." _
                    &amp; " Time: " &amp; CStr(m_nTimeSeriesCount) _
                    &amp; " Temp: " &amp; CStr(m_nTemperatureCount) _
                    &amp; " FT: " &amp; CBool(m_bFocusTrackEnabled) _
                    &amp; " Sat: " &amp; CBool(m_bSaturationMod) _
                    &amp; " Image: " &amp; CStr(m_oImageCapture.CaptureMode)
            End If
            Logger.Log sInfo : LogMessage sInfo

        End If

        ' Get the FocusTrack usage

        ' Check for minimal laser shutter flag.
        m_bMinimalShutter = Measurement.Properties("minimizeLaserExposure")
        ' don't set the minimise shutter flag if we are cycling the measurement (cycling is a setup utility so ignore the minimizeLaserExposure feature).
        if bCycling = FALSE then
            Scan.MinimiseLaserExposure = m_bMinimalShutter
        End If
        
        ' Log some details about the camera state
        ReportCameraStatus
        On Error Goto 0

        If m_nCount = 0 Then m_nCount = 1
        Dim sErrMsg

        ' Initialize for temperature series measurement   'PK: eTharmal acqtype is obsolete for WiRE4
'        If (m_eType AND eThermal) = eThermal Then
'            Logger.Log "Initialize for temperature series measurement"
'            Set m_oTStage = CreateTMSStage(System)
'            m_oTStage.Ramp = m_nRate
'            Sleep 100

'            ' Try and read the temperature from the stage. ie: check it works.
'            Dim n, t, e, src : e = vbObjectError + 1
'            On Error Resume Next
'                For n = 0 To 6
'                    Activity FormatMessage("Reading current temperature from the TMS stage")
'                    t = m_oTStage.Temperature
'                    e = Err.Number : src = Err.Source : sErrMsg = Err.Description
'                    Err.Clear
'                    If e = 0 Then Exit For
'                Next
'            On Error Goto 0
'            If e &lt;&gt; 0 Then
'                Err.Raise e, src, sErrMsg
'            End If
'    Else
        If (m_eType AND eThermal2) = eThermal2 Then
            Set m_oTStage = CreateTMSStage(System)
        m_bCollectTemperatureValues = False

        ElseIf m_bCollectTemperatureValues Then
            Set m_oTStage = CreateTMSStage(System)
            m_oTStage.Ramp = m_nRate
        End If

    if (m_bCollectTempProfile) then
        set m_oTempDL = CreateObject("Renishaw.WiREDataListCom")
        set m_oTimeDL = CreateObject("Renishaw.WiREDataListCom")
    end if

        ' Check for linefocus mapping measurements
        m_bLineFocusMapping = False
        On Error Resume Next
            m_bLineFocusMapping = CBool( Measurement.Properties("LineFocusMode") )
        On Error Goto 0
        If m_bLineFocusMapping Then Logger.Debug "line focus mapping enabled"

        ' Check we have a valid FocusTrack object if this is enabled. We could create one, but it shouldn't
        ' happen. The Wizard is supposed to sort this for us.
        If m_bFocusTrackEnabled Then
            If IsObject(FocusTrack) And Not(FocusTrack Is Nothing) Then
                Set FocusTrack.System = System
                If FocusTrack.UseInstStateAreaKey Then
                    FocusTrack.InstrumentState.AreaKey = InstrumentState.AreaKey
                End If
                FocusTrack.parentHWND = g_parentHWND
                Logger.Debug "Initialising focustrack with system object"
            Else
                sErrMsg = "FocusTrack is enabled but no FocusTrack named item is present!"
                Logger.Error sErrMsg
                Err.Raise vbObjectError + 1, "Acquisition_Init", sErrMsg
            End If
        End If

    End Sub

    ' if the wiredebug flag 'EnableTMSEmulation' is set then
    '   create an emulation stage, otherwise create the real thing.
    Private Function CreateTMSStage(oSystem)
        Dim oStage

        Dim oShell : Set oShell = CreateObject("WScript.Shell")
        On Error Resume Next
        If oShell.RegRead("HKEY_LOCAL_MACHINE\SOFTWARE\Renishaw\WiRE2\Debug\EnableTMSEmulation") = 0 Then
            Set oStage = New CTemperatureStage
        Else
            Set oStage = New CEmulationTemperatureStage
        End If
        'if the reg key did not exist then the errorNumber will be set so assume no emulation
        If Err.Number &lt;&gt; 0 Then Set oStage = CTemperatureStage
        On Error GoTo 0
    
        oStage.Init oSystem
        set CreateTMSStage = oStage
    End Function

    Public Property Get SeriesStartTime()
        SeriesStartTime = m_dtSeriesStart
    End Property

    Public Property Get ScanStartTime()
        ScanStartTime = m_dtScanStart
    End Property

    Public Property Get SampleBleachTime()
        SampleBleachTime = m_nBleachTime
    End Property


    Public Sub StopAfterScan
        m_bHaltAfterScan = True
        if (m_eMode = eCompleteSeries AND m_nTrueCount &gt; 1) then
            ' Doing a fast map scan with multiple points. Abort it after the current scan
            Scan.AbortAfterMapScan
        End If
        Activity FormatMessage("scanning")
        'TestForAbort    ' do it now if we can.
    End Sub

    Public Sub StopAfterAcc
        If m_bScanComplete Then
            System.Abort WIRESYSTEMLib.eWAS_USER_ABORT
            m_eTermination = WIRESYSTEMLib.eWAS_USER_ABORT  ' just in case a sequence was not running.
        Else
            Scan.AbortAtEndOfAccumulation
            m_bHaltAfterAcc = True
            Activity FormatMessage("scanning")
        End If
    End Sub

    Private Sub TestForAbort
        If (Not(IsScanRunning()) And (m_bHaltAfterScan or m_bHaltAfterAcc)) Then
            Logger.Log "Mmt TestForAbort aborting"
            'System.Abort WIRESYSTEMLib.eWAS_USER_ABORT
            m_eTermination = WIRESYSTEMLib.eWAS_USER_ABORT  ' because a sequence may not be running.
        Else
            Logger.Log "mmt TestForAbort not aborting; scanrunning = " &amp; CStr(IsScanRunning())
        End If
    End Sub

    Public Property Get CurrentScan()
        CurrentScan = m_nScan
    End Property

    Public Property Get Count()
        Count = m_nCount
    End Property

    Public Property Get AcqType()
        AcqType = m_eType
    End Property

    Public Property Get AcqMode()
        AcqMode = m_eMode
    End Property

    ' These are set by the Wizard as Measurement.Properties("MeasurementType")
    Public Property Get AcquisitionTypeName()
        Select Case m_eType
            Case eSingle
                AcquisitionTypeName = "SingleScan"
            Case eTiming
                AcquisitionTypeName = "TimeSeries"
            Case eDepths
                AcquisitionTypeName = "DepthSeries"
            Case eThermal
                AcquisitionTypeName = "TemperatureSeries"
            Case eXYArea
                AcquisitionTypeName = "AreaMap"
            Case (eDepths OR eXYArea)
                AcquisitionTypeName = "AreaMap DepthSlice"
            Case eCustomSeries
                AcquisitionTypeName = "Custom Series"
            Case eTriggeredSeries
                AcquisitionTypeName = "UserSeries"
            Case eThermal2
            AcquisitionTypeName = "Temperature Controlled Series"
            Case Else
                AcquisitionTypeName = "UnknownType"
        End Select
    End Property

    Public Property Get Interval()
        Interval = m_nInterval
    End Property

    Public Property Get IsTimedOut()
        IsTimedOut = m_bTimedOut
    End Property

    Public Property Get Aborted()
        Aborted = (m_eTermination = WIRESYSTEMLib.eWAS_USER_ABORT) And Not(m_bTimedOut)
    End Property

    Public Property Get Failed()
        Failed = (m_eTermination = WIRESYSTEMLib.eWAS_FAILED_TO_START) _
            Or (m_eTermination = WIRESYSTEMLib.eWAS_FAILED_SEQUENCE) _
            Or (m_eTermination = WIRESYSTEMLib.eWAS_CAMERA_DISCONNECTED) _
            Or m_bTimedOut
    End Property

    Public Sub CheckFinalTemperature()
        On Error Resume Next
        If m_eType = eThermal Then
            Dim dEstFinal: dEstFinal = m_nInitialValue + (m_nInterval * (m_nCount - 1))
            Dim dActFinal: dActFinal = m_oTStage.Temperature
            Dim dReqFinal: dReqFinal = Measurement.Properties("TemperatureSeriesFinal")
            Dim s : s = FormatMessage("Final sample temperature %1 °C.", FormatNumber(dActFinal-AbsoluteZero,1))
            If dReqFinal &lt;&gt; dEstFinal Then
                s = s &amp; " " &amp; FormatMessage("Asynchronously setting to %1 °C.", FormatNumber(dReqFinal-AbsoluteZero,1))
                m_oTStage.SetTemperatureAsync dReqFinal
            End If
            Logger.Debug s : Activity s
        End If
    End Sub

    Public Function DisplayValue(oMemFile, vValue, eUnits)
        On Error Resume Next
        Dim sDisplay : sDisplay = CStr(vValue)
        Dim sUnits : sUnits = oMemFile.DataUnitDescription(eUnits)
        If Err.Number = 0 Then
            Dim aUnits : aUnits = Split(sUnits, "/")
            If UBound(aUnits) &gt; 0 Then sUnits = Trim(aUnits(UBound(aUnits)))
            sDisplay = sDisplay &amp; " " &amp; sUnits
        End If
        On Error Goto 0
        DisplayValue = sDisplay
    End Function

    Public Property Let TerminationStatus(newVal)
        m_eTermination = newVal
    End Property

    Public Property Get TerminationStatus()
        TerminationStatus = m_eTermination
    End Property

    ' Revise the duration estimate for this acquisition (in s)
    Public Property Get DurationEstimate()
        Dim nScansLeft : nScansLeft = (m_nCount - m_nScan - 1)
        If m_nAvgScanTime = 0 Then
            Dim nInterval : nInterval = 0
            If m_eType = eTiming Then nInterval = m_nInterval
            DurationEstimate = (Scan.DurationEstimate * nScansLeft) + (nInterval * nScansLeft)
        Else
            DurationEstimate = m_nAvgScanTime * nScansLeft
        End If
    End Property

    Public Sub ScanComplete()
        m_bScanComplete = True
    End Sub

    Public Property Get FocalPoint()
        FocalPoint = m_dFocalPoint
    End Property

    ' FocusTrack results we want added to the next dataset (FT is run during the pre-scan).
    ' This means we know which DS the FT operated on.
    Public Sub FocusTrackComplete(bSuccess, dCentre, oMemFile)
        Dim sMsg  : sMsg = ""
        Dim eCode : eCode = 0 ' 0 is eFSS_UNINITIALISED
        On Error Resume Next
            sMsg = FocusTrack.CompletionString
            eCode = FocusTrack.CompletionStatus
        On Error Goto 0
        m_sFocusTrackCompletionString = sMsg
        m_eFocusTrackCompletionCode = eCode
        Logger.Debug "FocusTrack completed with centre " &amp; FormatNumber(dCentre) &amp; ", code " &amp; eCode &amp; " """ &amp; sMsg &amp; """"
        Activity FormatMessage("FocusTrack completed with centre %1, code %2 '%3'", FormatNumber(dCentre), eCode, sMsg)
        m_dFocalPoint = dCentre
        Scan.FocustrackValue  = m_dFocalPoint
        m_bFocusTrackComplete = True
    End Sub

    'To verify whether to create file name and DataSaveMode corrected...
     Public Sub CheckDataSaveModeAndFile()

        ' Support cycling measurements.
        Dim bCycling : bCycling = False
        On Error Resume Next
        bCycling = CBool(Measurement.Properties("cycling"))
        ' We need to force the filename into the scan if we have one so that the first call to 
        ' Transfer() doesn't create a temporary file
        If m_nScan = 0 Then
            If Len(Measurement.DataSaveFile) &gt; 0 Then
                If (Measurement.DataSaveMode = WIREEXPERIMENT2Lib.dsmIncrement) Then
                    Measurement.DataSaveFile = UniqueFilename(Measurement.DataSaveFile)
                    Measurement.DataSaveMode = WIREEXPERIMENT2Lib.dsmIncrement
                    Logger.Log "Changing data save file to " &amp; Measurement.DataSaveFile
                End If
                Logger.Debug "CheckDataSaveModeAndFile-&gt; save file '" &amp; Measurement.DataSaveFile &amp; "'"
            Else
               ' bug #3821: if no filename, provide a persistent temp file (queue cleans them after a week).
                Dim bPersistentTempFile: bPersistentTempFile = True
                On Error Resume Next
                    bPersistentTempFile = CBool(Measurement.Properties("persistentTempFile"))
                On Error Goto 0
                If bPersistentTempFile Then
                    Measurement.DataSaveFile = getTempWdfFilename
                    Measurement.DataSaveMode = WIREEXPERIMENT2Lib.dsmOverwrite
                    Logger.Log "Forcing filename to a chosen temporary file '" &amp; Measurement.DataSaveFile &amp; "'"
                End If
            End If
        End If
    End Sub


    Public Sub Run()
        ReportCameraStatus
        m_dtSeriesStart = UTCNow()
        Dim nSumScanTime : nSumScanTime = 0
        m_nAvgScanTime = 0
        m_nScan = 0
        ' Check if the scan zeldac type is measurement. If it is we need to tell the scan it's being run for the first time
        CheckZeldacForFirstScan
        'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
        if (g_TestMeasurementError = 101) then  Err.Raise vbObjectError + 1, "Acquisition.Run", "Test error 101 from before running measurement loop"
        Measurement.WdfProperties("WiREData").Add "SequenceDurationMS", System.sequenceDurationMS 
        Do While ((m_nScan &lt; m_nCount) Or ((m_eType And eTriggeredSeries) = eTriggeredSeries) _ 
            Or ((m_eType And eThermal2) = eThermal2))

            m_dtScanStart = UTCNow()
            
            If Not(PreScan) Then 
            Exit Do 
            End If
            
            If m_eMode = eCompleteSeries And m_nScan = 0 Then
                PostScan    ' Do a file save now so that we can resave by simply calling save with no file name
            End If

            If Me.Aborted Then 
                Exit Do ' TimeSeries sleep / Temperature ramp may be aborted.
            End If
            Dim sCompleted
            If m_nCount &lt; 1 Then 
                Activity FormatMessage("Beginning scan.")
                sCompleted = FormatMessage("Completing scan.")
            Else
                Activity FormatMessage("Beginning scan %1 of %2", m_nScan + 1, m_nCount)
                sCompleted = FormatMessage("Completing %1 of %2", m_nScan + 1, m_nCount)
            End if
            'record the last collect sequence duration - this is obviously irrelevant for multiple collect 
            'sequences handled from the measurement script; but for in-scan managed
            'collections this value is very useful
            Measurement.WdfProperties("WiREData").Item("SequenceDurationMS") = System.sequenceDurationMS  'WDFADD  PVK added -TODO need to change this in Experiment2
            
            DoScan Scan ' uses global Scan object
            
            Activity sCompleted
            ReportCameraStatus
        
            ' update the end condition
            On Error Resume Next
            Err.Clear
            If m_eMode = eCustomSeries Then
                m_nCount = Measurement.Properties("customScanCount")
                Logger.Debug "Read customScanCount: " + CStr(m_nCount)
            ElseIf (m_eType AND eXYArea) = eXYArea Then
                ' retrieve move state
                Dim bNoMove : bNoMove = False
                bNoMove = CBool(Measurement.Properties("dontMoveStage"))
                If (Err.Number = 0) And (bNoMove = true) Then
                    ' additional scans. update end condition
                    m_nCount = m_nCount + 1
                End If
           End If
            On Error Goto 0
            'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
            if (g_TestMeasurementError = 106) then  Err.Raise vbObjectError + 1, "Acquisition.Run", "Test error 106 raised after Scan"
            TestForAbort    ' if AbortAfterScan/Acc was called this cause me.Aborted to be TRUE.
            If Me.Aborted Then 
                Exit Do    ' must be after the TestForABort.
            End If
            PostScan

            nSumScanTime = nSumScanTime + (DateDiff("s", m_dtScanStart, UTCNow()) * 1000)
            m_nAvgScanTime = nSumScanTime / (m_nScan + 1)
            Logger.Debug "Average scan completion time at scan " &amp; m_nScan &amp; " is " &amp; CStr(m_nAvgScanTime / 1000) &amp; "s."

            If (m_eType and eThermal2) = eThermal2 Then
                if (Not UpdateRampState) Then 
                    Exit Do 
                End If
            End If

            Dim bNoIncrement : bNoIncrement = False
            On Error Resume Next
            'WXDREMOVE : TODO : Need to change appropriately
            'bNoIncrement = CBool(Measurement.Properties("dontIncrementDatasetIndex"))
            If Not bNoIncrement Then 
                m_nScan = m_nScan + 1
                Logger.Debug "End of run loop. m_nScan = " + CStr(m_nScan) + " m_nCount = " + CStr(m_nCount)
            End If
            On Error Goto 0
        Loop
    'TODO : Mapping need to check with Pat
'        If ((m_eType And eTriggeredSeries) = eTriggeredSeries) or _
'            ((m_eType And eThermal2) = eThermal2) Then Scan.FinalizeMapping Measurement.Result  'WXDREMOVE Then Scan.FinalizeMapping Measurement.Result
        'Then Scan.FinalizeMapping Measurement.WdfProperties  'WDFADD  Need to uncomment this while removing  WXD part
        If ((m_eType And eThermal2) = eThermal2) Then
            On Error Goto 0
'            Dim sDSName: sDSName = "DataSet" + CStr(Measurement.Result.NumberOfDataSets)
'            Dim sDSLabelKey: sDSLabelKey = "dataSetLabels" + CStr(Measurement.Result.NumberOfDataSets)
            ' Thermal2 measurements collect the temperature profile as we go along.
            ' We now need to insert this data into the result
'            Measurement.Result.CreateDataList sDSName, "DataList0", 0, False
'            Measurement.Result.CreateDataList sDSName, "DataList1", 0, False
'            Measurement.Result.Data(sDSName, "DataList0", 0, -1) = m_oTimeDL.Data(0, -1)
'            Measurement.Result.Data(sDSName, "DataList1", 0, -1) = m_oTempDL.Data(0, -1)
'            Measurement.Result.Element("", sDSLabelKey) = "Temperature profile"
            
            Dim vTempDL : vTempDL = m_oTempDL.Data(0, -1)
            Dim vTimeDL : vTimeDL = m_oTimeDL.Data(0, -1)

            'Let's clear the both datalist's
            m_oTempDL.Clear
            m_oTimeDL.Clear

            'Update Aux block datalist's...
            On Error Resume Next ' ignore error when aborting and no temperature data ready.
            Logger.Debug "Updating temperature series with " &amp; CStr(1+UBound(vTempDL)) &amp; " points."
            Scan.UpdateAuxData vTempDL, vTimeDL
            If Err.Number &lt;&gt; 0 Then Logger.Error "Failed to record temperature auxiliary data: " &amp; Err.Description
            On Error Goto 0

            ' Add dataset metadata
'            Dim oDS: set oDS = Measurement.Result.Element("", sDSName)
'            oDS.NumberOfDataLists = 2
'            oDS.Add "dataListUnits0", WIREFILEHANDLERLib.eSECONDS
'            oDS.Add "dataListType0", WIREFILEHANDLERLib.eTIME
'            oDS.Add "dataListLabels0", "Elapsed Time / s"
'            oDS.Add "dataListUnits1", WIREFILEHANDLERLib.eCELCIUS
'            oDS.Add "dataListType1", WIREFILEHANDLERLib.eTEMPERATURE
'            oDS.Add "dataListLabels1", "Temperature / ?C"
            
'            Dim oARs: set oARs = Measurement.Result.GetNewAnalysisResults()
'            Dim oAR : set oAR = CreateObject("Renishaw.WiREAnalysisResultCom")
'            oAR.Type = "Temperature profile"
'            oAR.Result = sDSName
'            oAR.Version = s_Version
'                Dim oNet: Set oNet = CreateObject("WScript.Network")
                ' Get the username from the Wsh Network object
'                oAR.Operator = oNet.UserName
'                oAR.ReadOnly = True
'                oARs.Add(oAR)
'                Set oAR = Nothing
'                set oARs = Nothing
'                Set oNet = Nothing
        End if

    If Me.Aborted Then
        'Dim sStatus1: sStatus1 = Measurement.WdfProperties("WiREData").Item("lastScanCompletionStatus")
        'If sStatus1 = "Incomplete" Then
        '    Measurement.WdfProperties("WiREData").Item("lastScanCompletionStatus") = "Aborted"
        '    Measurement.WdfProperties("WiREData").Item("ErrorDescription") = "Measurement aborted."
        'End If
        ' if we were performing mapping on the fly (aka Live Imaging) and the measurement
        '   was aborted, then make sure that the Scan's liveImaging threads are cleaned up.
        Logger.Debug "Measurement aborted - calling scan.FinalizeMapping"
        Scan.FinalizeMapping
    End If

        ' Ensure that the video is left in USER mode
        EnsureUserVideoMode

        DisconnectFocusTrack    ' added to ensure it does not hold itself or the system open.


    End Sub

    Private Sub CheckZeldacForFirstScan
        On Error Resume Next

        dim res: res = System.TestAreaKey( Scan.AreaKey)
        Logger.Log "Getting Zeldac object from system: " &amp; res
        dim oZeldac: set oZeldac = System.HostedObject(WIRESYSTEMLib.eSHO_PER_AREAKEY_ITEMS).itemByID("zeroLevel_darkCurrent", Scan.AreaKey.ID)
        if Err.Number = 0 then
            if oZeldac.ExpiryType = 1 then     ' 1 = EZeldacExpiryType::eZET_MEASUREMENT
                oZeldac.UpdateOnNextScan = true
                Logger.Log "Setting Zeldac::UpdateOnNextScan to true"
            end if
        else
            Logger.Error "Failed to retrieve the Zeldac object. " &amp; Err.Description
        end if
        Err.Clear
        On Error Goto 0
    
    End Sub

    ' Ensure that the video is left in USER mode
    Private Sub EnsureUserVideoMode
        Logger.Debug "EnsureUserVideoMode"
        If IsObject(System) then
            Dim CurrentVideoMode
            CurrentVideoMode=System.VideoUseMode
            If CurrentVideoMode &lt;&gt; eUSERVIDEO Then
                System.VideoUseMode=eUSERVIDEO
            End If
        Else
            Logger.Error "System is NULL"
        End If
    End Sub
    Private m_nRampID
    Private m_bRampStarted
    Private m_rampStart
    Private m_currentRamp
    Private m_increment
    Private m_lastCollection
    Private m_bRampPaused
    Private m_RampElapsed

    Private Function ContinueMeasurement()
        Dim bContinue: bContinue = False
        On Error Resume Next
        bContinue = Measurement.Properties("continueMeasurement")
        If Err.Number &lt;&gt; 0 Then bContinue = True    ' flag not present so continue
        On Error Goto 0
        ContinueMeasurement = bContinue
    End Function
    
    Private Function RampPaused()
        Dim bPaused: bPaused = False
        On Error Resume Next
        bPaused = Measurement.Properties("rampPaused")
        If Err.Number &lt;&gt; 0 Then bPaused = False    ' flag not present so continue
        On Error Goto 0
        RampPaused = bPaused
    End Function
    
    ' called to determine if we want to capture images
    '    before we collect data so we know where to start the podule.    
    Public Function ImageCaptureBeforeDataCollection()
        ImageCaptureBeforeDataCollection = False
        
        Dim ICM: ICM = m_oImageCapture.CaptureMode

        ' try to read the Image capture mode from the temperature series if there is one.
        If ((m_eType and eThermal2) = eThermal2) Then
            If m_oTempRamps Is Nothing Then _
                set m_oTempRamps = Measurement.Properties("TemperatureRamps")

            if (m_oTempRamps.Count &gt; 0) Then
                Dim oRamp: Set oRamp = m_oTempRamps.Item(1)
                ICM = oRamp.ImageCaptureMode
            End if
        End if

        If ICM = 1 or ICM = 3 Then  ' 1 is BEFORE and 3 is BOTH
            ImageCaptureBeforeDataCollection = True
        End if

    End Function
    
    Private Function RampToNextCollection()
        Do While (not me.aborted)
            If (Not m_bRampStarted) Then
                m_bRampPaused = RampPaused
                if (m_bRampPaused) then
                    ' If the ramping is paused then we cannot start the ramp
                    ' Collect the current temperature the the profile
                    Dim T
                    T = m_oTStage.ReadQuietly - 273.15
            
                    ' Add the current temperature to the plot
                    m_oTempDL.Add T
                    m_oTimeDL.Add UTCNow()
            
                    ' However, we may still collect if the continueMeasurement flag is true
                    if (ContinueMeasurement) then
                        RampToNextCollection = true
                        Exit Function
                    End If
                    Sleep2(500)
                else
                    ' Start the next ramp section
                    if (m_nRampID &gt; m_oTempRamps.Count) then 
                        ' No more ramps.
                        RampToNextCollection = false
                    Exit Function
                    else
                        set m_currentRamp = m_oTempRamps.Item(m_nRampID)
                        dim ICM : ICM = m_currentRamp.ImageCaptureMode
                        if (ICM = WiRETemperatureRampsLib.eICM_NONE) then
                            m_oImageCapture.CaptureMode = 0
                        elseif (ICM = WiRETemperatureRampsLib.eICM_BEFORE) then
                            m_oImageCapture.CaptureMode = 1
                        elseif (ICM = WiRETemperatureRampsLib.eICM_AFTER) then
                            m_oImageCapture.CaptureMode = 2
                        elseif (ICM = WiRETemperatureRampsLib.eICM_BOTH) then
                            m_oImageCapture.CaptureMode = 3
                        end if
                        if (m_currentRamp.DataCollectionMode = WiRETemperatureRampsLib.eDCM_INCL_START or _
                            m_currentRamp.DataCollectionMode = WiRETemperatureRampsLib.eDCM_INCL_BOTH) then
                            ' Don't start the ramp here. We'll start it in post scan
                            ' Just drop out because this is the time to take the first scan of this ramp.
                            RampToNextCollection = true
                            Exit Function
                        Else
                            StartRamp m_currentRamp
                        End if
                    End If
                End If
            End If

            if (m_bRampStarted) then
                dim res: res = WaitForNextCollection
                if (res &lt;&gt; 2) then
                    RampToNextCollection = (1 = res)
                    exit Function
                end if
            end if
        Loop
    
    End Function
    
    ' Called to update the temperature ramps progress after a scan. Return false if we should finish the measurement 
    ' now, or true if we should continue on
    Private Function UpdateRampState()
        if (RampPaused) then
            ' Ramps are paused. We cannot complete while paused
            UpdateRampState = true
        elseif (Not m_bRampStarted) then
            ' If we've got to post scan and the ramp hasn't been started, then we can assume
            ' that the data collection mode means that the ramp should be started after the first scan
            ' Start the ramp now
            StartRamp m_currentRamp
            UpdateRampState = true
        else
   
            dim currentVal
            dim totalDelta
            dim endVal
    
            ' Check to see if this ramp is over
            if (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP) Then
                currentVal = m_oTStage.ReadQuietly - 273.15
                totalDelta = Abs(m_rampStart - currentVal)
                endVal = m_currentRamp.EndTemperature
            elseif (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_HOLD) Then
                currentVal = Now()
                totalDelta = Abs(m_rampStart - currentVal)
                endVal = m_rampStart + (m_currentRamp.HoldTime / 86400)
            end if
            if (totalDelta &gt;= Abs(m_rampStart - endVal)) then
                m_bRampStarted = 0
                m_nRampID = m_nRampID + 1
                Logger.Log "Next ramp in UpdateRampState. TD = " &amp; CStr(totalDelta) &amp; " rs=" &amp; CStr(m_rampStart) &amp; " ev=" &amp; CStr(endVal)
        
                ' Check to see if there are any more ramps left
                UpdateRampState = m_nRampID &lt;= m_oTempRamps.Count
            Else
                UpdateRampState = True
            End If
        End If
    End Function
    
    Private Sub StartRamp (currentRamp)
        if currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP then
            ' Ramp to the given temperature
            Activity "Starting ramp to " &amp; CStr(currentRamp.EndTemperature) &amp; "°C at " &amp; CStr(currentRamp.RampRate) &amp; "°C/min"
            m_rampStart = m_oTStage.ReadQuietly - 273.15
            m_oTStage.Ramp = currentRamp.RampRate
            m_oTStage.SetTemperatureAsync currentRamp.EndTemperature + 273.15
        else 
            m_RampElapsed = 0
            m_rampStart = Now()
        end if
        m_lastCollection = m_rampStart
        m_bRampStarted = true
        m_bRampPaused = false
    End Sub

    Private Sub PauseCurrentRamp()
        if m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP then
            ' Stop this ramp. When we resume we will simply set the target temperature again. Effectively restarting the ramp
            ' from whatever the temperature is at that point
            Activity "Pausing ramp"
            m_oTStage.Hold
        else 
            Activity "Pausing ramp"
            m_RampElapsed = m_RampElapsed + (Now() - m_rampStart)
        end if
        m_bRampPaused = true
    End Sub
    
    Private Sub ResumeRamp()
        if m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP then
            ' Resume this ramp. Simply set the target temperature again effectively restarting the ramp.
            Activity "Resuming ramp"
            StartRamp m_currentRamp
        else 
            ' adjust ramp start so that the end time is correct
            Activity "Resuming hold. " &amp; CStr(CInt(m_currentRamp.HoldTime - (m_RampElapsed / 86400))) &amp; " S remaining"
            m_rampStart = Now() - m_RampElapsed
            m_RampElapsed = 0
        end if
        m_bRampPaused = false
    End Sub
    
    ' Wait for the next collection, ramp completion or abort. Return 0 on abort, 1 on collection due, 2 on ramp complete (no collection)
    Private Function WaitForNextCollection()
        dim currentVal
        dim totalDelta
        dim endVal
        dim increment
        if (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP) Then
            endVal = m_currentRamp.EndTemperature
            increment = m_currentRamp.AcquisitionInterval
        elseif (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_HOLD) Then
            ' the ramp specifies times in seconds, but the integer part of vbdate is a number of days
            endVal = m_rampStart + (m_currentRamp.HoldTime / 86400)
            increment = m_currentRamp.AcquisitionInterval/86400
        end if
    
        WaitForNextCollection = 0
        Do While (not Me.Aborted)
            Dim T
            T = m_oTStage.ReadQuietly - 273.15
        
            ' Add the current temperature to the plot
            m_oTempDL.Add T
            m_oTimeDL.Add UTCNow()
        
            ' Check to see if the measurement property has been set to pause the ramp
            if (RampPaused) then
                if (not m_bRampPaused) then
                    ' The ramp wasn't paused before now. Pause the ramp
                    Activity "Pausing ramp"
                    PauseCurrentRamp
                end if
        
                if (ContinueMeasurement) then
                    ' The flag to collect a single spectrum is set
                    Activity "Collecting spectrum on command"
                    WaitForNextCollection = 1
                    Exit Function
                end if
            else
                if (m_bRampPaused) then
                    ' This ramp was paused. Restart it
                    Activity "Resuming ramp"
                    ResumeRamp
            
                    ' recalc interval values
                    if (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP) Then
                        endVal = m_currentRamp.EndTemperature
                        increment = m_currentRamp.AcquisitionInterval
                    elseif (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_HOLD) Then
                        ' the ramp specifies times in seconds, but the integer part of vbdate is a number of days
                        endVal = m_rampStart + (m_currentRamp.HoldTime / 86400)
                        increment = m_currentRamp.AcquisitionInterval/86400
                    end if

                end if

                if (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP) Then
                    currentVal = FormatNumber(T, 2)
                    Activity "Ramping to " &amp; CStr(endVal) &amp; "°C Current T = " &amp; CStr(currentVal) &amp; "°C"
                    totalDelta = Abs(m_rampStart - currentVal)
                elseif (m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_HOLD) Then
                    currentVal = Now()
                    totalDelta = Abs(m_rampStart - currentVal)
                    Activity "Holding temperature for " &amp; CStr(CInt(m_currentRamp.HoldTime - (totalDelta * 86400))) &amp; " more seconds"
                end if
        
                ' The next collection will take place when we pass the next increment, or 
                ' when we reach the target val, but only if the collection mode is correct
                if (totalDelta &gt;= Abs(m_rampStart - endVal)) then
                    Logger.Log "Ramp finished. elapsed = " &amp; CStr(totalDelta)
                    if (m_currentRamp.DataCollectionMode = WiRETemperatureRampsLib.eDCM_INCL_END or _
                            m_currentRamp.DataCollectionMode = WiRETemperatureRampsLib.eDCM_INCL_BOTH) then
                        WaitForNextCollection = 1
                    else
                        m_bRampStarted = 0
                        m_nRampID = m_nRampID + 1
                        WaitForNextCollection = 2
                    end if
                    Exit Function
                elseif (m_currentRamp.DataCollectionMode &lt;&gt; WiRETemperatureRampsLib.eDCM_NONE and _
                    (increment &gt; 0 and  Abs(m_lastCollection - currentVal) &gt;= increment)) Then
                    ' The increment has passed. Collect now
                    Activity "Collecting data at increment"
                    WaitForNextCollection = 1
                    Exit Function
                end if
            end if
            Sleep2 (500)
        Loop
    End Function

    Private Function PreScan()
        PreScan = False
        Dim sMsg

        ' Reset the focustrack result log items
        m_eFocusTrackCompletionCode = 0 ' eFSS_UNINITIALISED
        m_sFocusTrackCompletionString = ""

        'PK: eTharmal acqtype is obsolete for WiRE4
'        If (m_eType and eThermal) = eThermal Then
'            ' Move to target temperature
'            If m_nScan = 0 Then
'                m_Point = m_nInitialValue
'            Else
'                m_Point = m_Point + m_nInterval
'            End If
'            Logger.Log "Changing temperature to " &amp; FormatNumber(m_Point-AbsoluteZero,1) &amp; "°C"
'            Activity FormatMessage("Changing temperature to %1 °C", FormatNumber(m_Point-AbsoluteZero,1))
'            On Error Resume Next
'                m_oTStage.Temperature = m_Point
'                If Err.Number &lt;&gt; 0 Then Logger.Error "Failed to set temperature: " &amp; Err.Description
'                Scan.CustomDataOriginValues = m_oTStage.Temperature ' enable monitoring
'                ' hold at the specified temperature.
'                If m_nTSHoldms &gt; 0 then
'                    Logger.Log "Holding temperature at " &amp; FormatNumber(m_Point-AbsoluteZero,1) &amp; "°C" &amp; _      
'                           " for " &amp; FormatNumber(m_nTSHoldms/1000, 0) &amp; "s"
'                    Activity FormatMessage("Holding temperature at %1°C for %2s", _
'                        FormatNumber(m_Point-AbsoluteZero,1), FormatNumber(m_nTSHoldms/1000, 0))
'                    SleepWithAbort m_nTSHoldms, 200
'                End If
'            On Error Goto 0
'        End If
'    
        'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
        if (g_TestMeasurementError = 102) then  Err.Raise vbObjectError + 1, "PreScan", "Test error 102 from before raiseBeforeScan event"
        ' Raise the before scan event here
        Logger.Log "Measurement script firing Measurement.RaiseBeforeScan..."
        Measurement.RaiseBeforeScan m_nScan
        Logger.Log "    Measurement script finished firing Measurement.RaiseBeforeScan. Err.Number = " &amp; CStr(Err.Number)

    
        If (m_eType and eThermal2) = eThermal2 Then
            dim bContinue: bContinue = RampToNextCollection
            ' Check for abort
            if (Not bContinue or Me.Aborted) then
            PreScan = false
            exit function
            end if
            Else
                If (m_eType And eTriggeredSeries) = eTriggeredSeries Then
                    Scan.CustomDataOriginValues = m_nScan
                    ' We could read the temperature here for the alternate origin value
                End If
        End If

        If (m_eType And (eXYArea Or eDepths)) &lt;&gt; 0 then
            ' We are using the map area object and the system object to do the moves for us. Tell it to move to the 
            ' next position
            System.MoveToMapAreaPosition m_nScan
            If m_nScan = 0 Then
               Logger.Log "Moving to start of map"
            End If
        End if

        ' Pause the multi-sequence operation and wait in a sleep loop for the "continueMeasurement" flag to be set
        Call WaitForContinueMeasurement
    
        ' Check for abort
        if (Me.Aborted) then
            PreScan = false
            exit function
        End if

        ' For the first acquisition for a map without image acquisition, prompt the user
        ' if we don't have a podule. NB: must prompt if only collecting the post image.
        dim bSystemHasMicroscope: bSystemHasMicroscope = true
        if ((System.SystemType And WIRESYSTEMLib.eWSY_RA801) = WIRESYSTEMLib.eWSY_RA801) or _
           ((System.SystemType And WIRESYSTEMLib.eWSY_RA802) = WIRESYSTEMLib.eWSY_RA802) then
            bSystemHasMicroscope = false
        End if
        ' if system is an RA100 then it does not have one either - but we don't run mapping 
        '   on these so this msg should never present.
        
        Dim bHavePodule: bHavePodule = CBool(System.SystemType And eWSY_PODULE)
        ' we must prompt on dual microscope systems if using the external scope.
        if bHavePodule And MicroscopeUsesExternalPath(System) then _
            bHavePodule = false' pretend there is no podule...
            
        If bSystemHasMicroscope And Not bHavePodule And g_bUseCollectWarning Then
            If m_nScan = 0 _
              And Not(m_bFocusTrackEnabled) _
              And ((m_eType AND eXYArea) = eXYArea Or (m_eType AND eDepths) = eDepths) _
              And (m_oImageCapture.CaptureMode = 0 Or m_oImageCapture.CaptureMode = 2) Then
                MsgBox FormatMessage(g_sDataCollectMessage), vbOKOnly + vbQuestion + vbSystemModal, _
                  FormatMessage(g_sDataCollectTitle)
            End If
        End If
    
        ' Do FocusTrack after stage motion but before scanning.
        If m_bFocusTrackEnabled Then
            If Not(bHavePodule) And (m_nScan = 0 Or m_oImageCapture.CaptureMode &lt;&gt; 0) Then
                MsgBox FormatMessage(g_sDataCollectMessage), vbOKOnly + vbQuestion + vbSystemModal, _
                  FormatMessage(g_sDataCollectTitle)
            End If
            If (m_nScan Mod m_nFocusTrackInterval) = 0 Then
                Activity FormatMessage("Adjusting focus.")
                m_bFocusTrackComplete = False

                FocusTrack.Start

                Do While Not m_bFocusTrackComplete
                    Sleep 250
                Loop                

                ' extended scans close the laser shutter instead of the ccd shutter on completion - so we we need to 
                '   re-assert the instrument state here before we run the next scan.
                ' so read the current instrument state
                Dim oIS: set oIS = CreateObject("Renishaw.WiREInstStateCom")
                oIS.System = System
                oIS.InitialiseFromSystem
                if oIS.ShutterOpen &lt;&gt; InstrumentState.ShutterOpen then
                    Logger.Debug "Re-applying the instrument state for extended scans after focustrack"
                    Instrument.Apply
                    Logger.Debug "On completion of focustrack, Laser Shutter Open reset back to " &amp; CStr(InstrumentState.ShutterOpen)
                End If

            End If
        End If

        m_oImageCapture.GrabImage 1, Not(m_bMaximizeWhitelight) ' maybe capture the pre image
        if (Acquisition.MinimizeLaserShutter() = true) or _
            Acquisition.MaximizeWhitelight or _
            Acquisition.ImageCaptureBeforeDataCollection then
           Logger.Debug "Forcing instrument state to instrument"
           On Error Resume Next
           Instrument.Apply ' force switch to raman view
           If Err.Number &lt;&gt; 0 Then Logger.Error Err.Source &amp; ": " &amp; Err.Description
           On Error Goto 0
        end if
        
        ' If using PAF, start it running here - we have moved to start position and are in Raman mode.
        If Scan.UsePAF Then
            Logger.Log "Measurement Starting LiveTrack tracking..."
            Scan.StartPAFTracking
        End If 

        'To create file if not exist and check whether to increment or not...
        CheckDataSaveModeAndFile
        
    If (m_eType and eThermal2) = eThermal2 Then
        ' It's important to record the stage temperature and ramp rate as close as possible to the data collection
        Dim T
        dim arrParams(1)
        T = m_oTStage.ReadQuietly - 273.15
        arrParams(0) = T
        if m_currentRamp.RampType = WiRETemperatureRampsLib.eRT_RAMP then
        m_lastCollection = T
            if (T &gt; m_currentRamp.EndTemperature) then
            arrParams(1) = -m_currentRamp.RampRate
        else
            arrParams(1) = m_currentRamp.RampRate
        end if
        else
            arrParams(1) = 0
        m_lastCollection = Now()
        end if
        Scan.AlternativeDataOriginValues = arrParams
    elseif m_bCollectTemperatureValues then
        Scan.AlternativeDataOriginValues = m_oTStage.ReadQuietly - 273.15
    End If

        'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
        if (g_TestMeasurementError = 103) then  Err.Raise vbObjectError + 1, "PreScan", "Test error 103 from After preScan"
        
        PreScan = True
    End Function

    Private Sub PostScan()
        Dim sLogMessage
        m_oImageCapture.Reset ' clear any capture images

        dim bSaveNow: bSaveNow = false
        dim elapsedTimeS
        dim lastS, lastM, lastH, nowS, nowM, nowH
        lastS = Second(m_lastSave)
        lastM = Minute(m_lastSave)
        lastH = Hour(m_lastSave)

        nowS = Second(Time())
        nowM = Minute(Time())
        nowH = Hour(Time())

        if nowH &lt; lastH then nowH = lastH+24
        elapsedTimeS = (nowH-lastH)*60*60 + (nowM-lastM)*60 + nowS-lastS

        ' the autosave has been set to 1 for the in-scan mapping. However, if it is a 
        '   focustrack map then we only want to save once every 20 minutes or so.        

        if m_eMode = eInteruptedSeries then    ' ie a focustrack map ?
            Logger.Log "eInteruptedSeries last save " &amp; CStr(m_lastSave) &amp; _
                  ", now = " &amp; CStr(Time()) &amp; ": elapsed = " &amp; CStr(elapsedTimeS) &amp; "s"

            If (m_nScan = 0) or (elapsedTimeS &gt; (20*60)) then    ' save every 20 minutes.
                bSaveNow=true
            end if
        end if
        
        If bSaveNow Then
        m_lastSave = Time()
        'bug #1662: dont save as eSPC_EVEN for incremental saves
'        Dim eFileFormat : eFileFormat = Measurement.DataFileFormat          //WXDREMOVE
'        If eFileFormat = eSPC_EVEN Then eFileFormat = eSPC

'        Logger.Log "Autosaving measurement result on scan #" &amp; CStr(m_nScan)   //WXDREMOVE : Can be removed as Autosave is not valid anymore
'        Activity FormatMessage("Autosaving measurement result on scan #%1", CStr(m_nScan))
'        If Measurement.DataSaveMode = WIREEXPERIMENT2Lib.dsmIncrement Then
'            Measurement.DataSaveFile = UniqueFilename(Measurement.DataSaveFile)
'            Measurement.DataSaveMode = WIREEXPERIMENT2Lib.dsmOverwrite
'            Logger.Log "Changing data save file to " &amp; Measurement.DataSaveFile
'        End If
'        On Error Resume Next
        'WXDREMOVE -- WDFADD -PVK TODO : Need to implement below commented code for IncrementalSave   WDF file...
'        If TypeName(Measurement.Result) = "WiREMemoryFileCom" Then
'            Measurement.Result.Save Measurement.DataSaveFile, eFileFormat, True
'        Else
'            Dim nFile
'            For nFile = 1 To Measurement.Result.Count
'                Dim sFilename
'                If nFile = 1 Then
'                sFilename = Measurement.DataSaveFile
'                Else
'                sFilename = SequencedFilename(Measurement.DataSaveFile, nFile-1)
'                End If
            'sFilename = GetBaseName(sFilename) &amp; "_x." &amp; GetExtension(sFilename)
'                Measurement.Result.Item(nFile).Save sFilename, eFileFormat, True
'            Next
'        End If

        ' The below error catch is for the 2 instances that a 'Permission denied' error has been 
        ' that ultimately can result in too many datasets being held open in memory (#2797)
'        If Err.Number &lt;&gt; 0 Then 
'            Logger.Error "Autosave error: " &amp; Err.Description
'            MsgBox FormatMessage("Error saving %s%n%2%n%nIt is recommended that you Abort and restart the measurement", sFilename, Err.Description), _
'            vbCritical, FormatMessage("WiRE2 Measurement")
'        end if

        'Logger.Debug "Calling garbage collector"
        'Measurement.Result.GarbageCollect WIREFILEHANDLERLib.gcfImmediate    'WZDREMOVE -- Can be removed as its not required anymore ...
        'If Err.Number &lt;&gt; 0 Then Logger.Error "Autosave error: " &amp; Err.Description
        On Error Goto 0
        End If
    End Sub

    Public Property Set ScanResult( newResult )
        if m_oScanResult is nothing then
            set m_oScanResult = newResult
        else
            Logger.Log "Set ScanResult: m_oScanResult is not nothing"
        end if
            
    End Property

    Public Sub WaitForSystem(nmsec)
        Dim oInstrument : Set oInstrument = New CInstrument
        oInstrument.WaitForIdleSystem System, nmsec, "WaitForSystem"
        Set oInstrument = Nothing
    End Sub

    Public Sub DoScan(oScan)
        m_bTimedOut = False
        if (m_eTermination &lt;&gt; eWAS_USER_ABORT) then 
            m_eTermination = WIRESYSTEMLib.eWAS_OK
        else
            ' Shouldn't be here.
            Logger.Error "Encountered user abort at start of DoScan. Will not perform scan"
            Exit Sub
        End If
        
        ' Saturation protection
        m_bSaturationMod = False    ' Initially no modification to the collection parameters for saturation
        Dim bSaturationCheck, lOriginalExpTime, dOriginalNDPercent
        Dim nRepeat: nRepeat = 0
        Dim nSatRepeat: nSatRepeat = 0
        On Error Resume Next
            nSatRepeat = CLng(Measurement.Properties("SaturationProtectionRepeat"))
            If (nSatRepeat &gt; 0) Then
                Scan.SaturationProtectionCount = nSatRepeat
            End If 
        On Error GoTo 0
        
        If (nSatRepeat &gt; 0 Or Scan.SaturationProtectionCount &gt; 0)  Then 
            ' Saturation protection: store the starting values of exposure time and ND percent
            lOriginalExpTime = oScan.ExpTimeInMillSecs
            dOriginalNDPercent = InstrumentState.NDPercent
            ' and set the starting values of the potentially modified variables to these
            m_lSaturationExpTime = lOriginalExpTime
            m_dSaturationNDPercent = dOriginalNDPercent
        End If
        
        Do
            ' Modify scan and instrument ND value (incl. apply) here if saturation protection is active.  This sets the 
            ' CAquisition member variables m_bSaturationMod = True and m_lSaturationExpTime, m_dSaturationNDPercent
            ' to the new values which will subsequently be logged to the resulting (unsaturated) dataset
            If (nSatRepeat &gt; 0) And (nRepeat &gt; 0) Then 
'                ModifyForSaturationProtection oScan        'WXDREMOVE : WDFADD - PVK Need to check for wdf
'                If m_bSaturationMod = False Then _
'                    Logger.Warn "CAquisition::ModifyForSaturationProtection failed - scan will be recollected with no parameters changed."
'                Activity FormatMessage("Saturation protection - repeat %1 (maximum %2)", nRepeat, nSatRepeat)
'                Logger.Log "Saturation protection - repeat " &amp; CStr(nRepeat) &amp; " (maximum " &amp; CStr(nSatRepeat) &amp; ")"
                ' Reset scan variables
                m_bTimedOut = False
                m_eTermination = WIRESYSTEMLib.eWAS_OK
                g_nUpdates = 0
            End If
            
            WaitForSystem 250
            
            On Error Resume Next
                Scan.MeasurementHandle = Measurement.Properties("queueHandle")
            On Error Goto 0

            on error resume next
            if Measurement.WdfProperties("WiREData").item("abortState") &lt;&gt; eWAS_OK then
                Logger.Warn "measurement finding abort set so setting terminate status to eWAS_USER_ABORT and not running scan."
                m_eTermination = eWAS_USER_ABORT
            end if
            on error goto 0

            if (m_eTermination &lt;&gt; eWAS_USER_ABORT) then 
                m_eTermination = WIRESYSTEMLib.eWAS_OK
            else
                ' Shouldn't be here.
                Logger.Error "Encountered user abort at start of DoScan. Will not perform scan"
                Exit Sub
            End If
            
            Dim nLocalScan, nLocalScanCount
            If (m_eMode &lt;&gt; eCompleteSeries) Then
             ' Do one scan at a time
                'Call DoScan3 for just one scan
                nLocalScan = m_nScan
                nLocalScanCount = 1

                ' Check here to see if the scan params have changed  (as part of the ATC workflow)          
                CheckScanParams

            Else
                ' Call DoScan3 for all scans
                nLocalScan = 0
                nLocalScanCount = -1
            End If
            
            'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
            if (g_TestMeasurementError = 104) then  Err.Raise vbObjectError + 1, "DoScan", "Test error 104 from before scan"
            'WXDREMOVE : WDFADD :PVK TODO Add check for Measurement.WdfProperties == WiREDictionary2Com
            LocalDoScan System, oScan, g_parentHWND, nLocalScan, nLocalScanCount
            
            ' Fire the scan started event
            Measurement.RaiseScanStarted m_nScan
            
            ' Final parameter in WaitForScanComplete is &lt;Check for saturation / log data&gt; - see sub for description 
            m_bSaturated = False    ' m_bSaturation will be reset True only if saturation has occurred.
            WaitForScanComplete oScan, 1200, Abs(CLng(nSatRepeat &gt; 0)) + Abs(CLng(nRepeat = nSatRepeat And nSatRepeat &gt; 0))
            
            on error resume next
            if Measurement.WdfProperties("WiREData").item("abortState") &lt;&gt; eWAS_OK then
                Logger.Warn "Scan aborted: measurement finding abort set so setting terminate status to eWAS_USER_ABORT."
                m_eTermination = eWAS_USER_ABORT
            end if
            on error goto 0

            'WDFADD -- TODO PVK Need Move below part to Scan...
            ' check to see if it was aborted:
            If oScan.NumOfAccumulations &lt;&gt; oScan.AccumulationsCollected Then
                'Measurement.Result.Element("", "AccumulationsCollected") = oScan.AccumulationsCollected    'WXDREMOVE -- Can be removed
                'Measurement.WdfProperties("WiREData").Item("AccumulationsCollected") = oScan.AccumulationsCollected  'WDFADD -- TODO PVK Need
            End If
            
            ' If we timed out then call abort and wait some more
            If (Not m_bScanComplete) And (Not Me.Aborted) Then
                Logger.Warn "Aborting scan due to measurement timeout."
                m_bTimedOut = True
                oScan.AbortScan True
                WaitForScanComplete oScan, 1200, 0
                Logger.Warn "Aborted scan due to measurement timeout - setting status"
                Measurement.WdfProperties("WiREData").Item("lastScanCompletionStatus") = "Timed out"    'WDFADD -- PVK added
                Exit Do
            End If
            nRepeat = nRepeat + 1
        Loop Until ((m_bSaturated = False) Or (nRepeat &gt; nSatRepeat))
    
        '' if we are still saturated then move on.
        'if nSatRepeat &gt; 0 then
            '' if the last collect was still saturated then we need to pretend that 
            ''   it succeeded - which means the below line must update m_LastDatasetCount to 
            ''   the correct value.
        '    Dim oCollectedDatasets
        '    Set oCollectedDatasets = Measurement.Result.Element("","collectedDatasets")
         '   if IsObject(oCollectedDatasets) And Not(oCollectedDatasets Is Nothing) then
         '       if m_bSaturated = True And nSatRepeat &gt; 0 then _
          '              m_LastDatasetCount = oCollectedDatasets.Count
          '  end if
        'end if

        'If m_bSaturationMod Then 
            '' Restore original scan and instrument state settings here if saturation protection is active
         '   oScan.ExpTimeInMillSecs = lOriginalExpTime
         '   If (m_dSaturationNDPercent &lt;&gt; dOriginalNDPercent) Then 
                '' Ensure we only reapply instrument state where necessary
          '      InstrumentState.NDPercent = dOriginalNDPercent
           '     If Not(Instrument Is Nothing) Then Instrument.ApplyLampsAndMotors
          '  End If
        'End If
    End Sub

    '
    ' checks to see if the user has changed the scan parameters (using the Advanced Temperature Series control).
    ' The results will only be logged if the first scan has been run (so the scan has a result filename).
    '
    Private Sub CheckScanParams()
        Dim dExpTime: dExpTime = Scan.ExpTimeInMillSecs
        Dim nAccs: nAccs = Scan.NumOfAccumulations
        Dim dLaserPower: dLaserPower = InstrumentState.NDPercent
        
        if (dExpTime &lt;&gt; m_dExpTime Or nAccs &lt;&gt; m_nAccs Or dLaserPower &lt;&gt; m_dLaserPower) Then
            ' Something has changed
            Dim oEntry: set oEntry = CreateObject("Renishaw.WiREDictionaryCom")
            oEntry.Add "Acquisition index", m_nScan+1
            
            if (dExpTime &lt;&gt; m_dExpTime) then
                oEntry.Add "Exposure time (ms)", dExpTime
                Logger.Log "CheckScanParams : Exposure time changed from " + CStr(m_dExpTime) + " to " + CStr(dExpTime)
                m_dExpTime = dExpTime
            End If
            
            If (nAccs &lt;&gt; m_nAccs) Then
                oEntry.Add "Accumulation count", nAccs
                Logger.Log "CheckScanParams : Accumulations changed from " + CStr(m_nAccs) + " to " + CStr(nAccs)
                m_nAccs = nAccs
            End If
            
            If (dLaserPower &lt;&gt; m_dLaserPower) Then
                Logger.Log "CheckScanParams : Laser power changed from " + CStr(m_dLaserPower) + " to " + CStr(dLaserPower)
                oEntry.Add "Laser ND percent", dLaserPower
                m_dLaserPower = dLaserPower
                If Not(Instrument Is Nothing) Then Instrument.ApplyLampsAndMotors
            End If

            ' pass the dictionary to Scan and write the analysis block with the changed details.
            ' this will fail if the scan has not yet been run.
            On Error Resume Next
            Scan.SaveATCResults oEntry
            If Err.Number &lt;&gt; 0 Then
                Logger.Error "Scan.SaveATCResults failed to save modified scan settings to the result wdf file : " + CStr(Err.Number) + " : " + Err.Description
                Err.Clear
            End if
        End If
    End Sub
    
    ' We must trap any error from DoScan and reset our completion flag on error to avoid waiting for ever.
    Private Sub LocalDoScan(oSystem, oScan, hwnd,nScan, nCount)
        Dim code,src,desc
        On Error Resume Next   
        m_bScanComplete = False

        oScan.DoScan3 oSystem, hwnd, Measurement.WdfProperties, nScan, nCount,Measurement.DataSaveFile
        
        If Err.Number &lt;&gt; 0 Then
            code = Err.Number : src = Err.Source : desc = Err.Description
            m_bScanComplete = True
            On Error Goto 0
            Err.Raise code, src, desc
        End If
    End Sub

    Public Sub ReportCameraStatus()
        Dim bReport : bReport = False
        On Error Resume Next
        bReport = Measurement.Properties("reportCameraStatus")
        If bReport Then
            If m_oCameraWrapper Is Nothing Then
                Set m_oCameraWrapper = New CCameraWrapper
                m_oCameraWrapper.Init System
            End If

            Dim s : s = m_oCameraWrapper.ReportCameraStatus
            Logger.Warn s
        End If
        Err.Clear
    End Sub
    
    Private Property Get UsingExternalTriggers()
        UsingExternalTriggers = False
        Dim oTriggers: Set oTriggers = System.HostedObject(eSHO_EXT_TRIGGERS)
        Dim oTrigger
        Dim sKey
        If (IsObject(oTriggers)) Then
            For each sKey in oTriggers.Keys
                Set oTrigger = oTriggers.Item(sKey)
                If oTrigger.InputTrigger Then
                    If oTrigger.UseTrigger Then
                        UsingExternalTriggers = True
                        Logger.Log "Waiting on external triggers"
                        Exit For
                    End If
                End If
            Next
        End If
    End Property
    
    '
    ' UsingSoftwareTrigger
    '
    Private Property Get UsingSoftwareTrigger(oScan)
        UsingSoftwareTrigger = False
        
        On Error Resume Next    ' halt error handling.
        Dim softTriggersFlag
        softTriggersFlag = oScan.SoftwareTriggerState
        If softTriggersFlag AND eSTT_TRIGGER_IN = eSTT_TRIGGER_IN Then 
            UsingSoftwareTrigger = true
            Logger.Log "Waiting on Software triggers"
        End If
        On Error Goto 0         ' restore error handling.
    End Property


    private function sTimeString(nSeconds)
        dim sToDays:  sToDays  = (60*60*24)
        dim sToHours: sToHours = (60*60)
        dim sToMins:  sToMins  = (60)
    
        dim nsecs: nsecs = CLng(nSeconds)
        dim ndays: ndays = CLng(0)
        dim nhours: nhours = CLng(0)
        dim nmins: nmins = CLng(0)

        ndays = ExtractTimeUnit(nsecs, sToDays, nsecs)
        nhours = ExtractTimeUnit(nsecs, sToHours, nsecs)
        nmins = ExtractTimeUnit(nsecs, sToMins, nsecs)
    
        dim sTimeTxt: sTimeTxt = ""
        if ndays &gt; 0 then sTimeTxt = sTimeTxt + CStr(ndays) + " days "
        if nhours &gt; 0 then sTimeTxt = sTimeTxt + CStr(nhours) + " hours "
        if nmins &gt; 0 then sTimeTxt = sTimeTxt + CStr(nmins) + " mins "
        if nsecs &gt; 0 then sTimeTxt = sTimeTxt + CStr(nsecs) + "s"
        sTimeTxt = sTimeTxt + "."
        sTimeString = sTimeTxt
    end function

    ' returns the number of WHOLE times nDivisor goes into nInitial,
    ' and returns the remainder
    private function ExtractTimeUnit(nInitial, nDivisor, remainderOut)
        ExtractTimeUnit = 0
        Dim tmpRemainder: tmpRemainder = nInitial
        if nInitial &gt; nDivisor then 
            tmpRemainder = nInitial Mod nDivisor
        ExtractTimeUnit = (nInitial-tmpRemainder)/nDivisor
        end if
        ' we can only overwrite the 'out' remainder here because anticipated used
        '	is that this is the same variable as nInitial which we don't want to 
        '	change yet...
        remainderOut = tmpRemainder
    end function
    

    Public Sub WaitForScanComplete(oScan, nMilliseconds, nSaturationTestMode)
        ' Wait for the bScanComplete flag to become True. This is set by the ScanComplete
        ' handler. 
        ' Adding an extra two minutes (120secs = 120,000ms) to allow for motor movement
        ' bug #2208: change to the greater of 10% of ScanDurationEstimate or 120s
        ' Final parameter in WaitForScanComplete is &lt;Test for saturation / log data mode&gt;:
        ' = 0: no check, data will be logged (unless dontAddDatasets flag is set) 
        ' = 1: check for saturation and log data unless saturated
        ' = 2: check for saturation and log data regardless of result (last pass)
        Dim nTime    : nTime = 0.0   ' updated from ms to seconds for wire4.
        Dim nLimit   : nLimit = 2    ' how many tries do we give it?
        Dim nOverrun : nOverrun = 0
        Dim sErr     : sErr = ""
        g_bSleeping = True
        
        Dim bUsingTriggers: bUsingTriggers = UsingExternalTriggers or UsingSoftwareTrigger(oScan)

        Dim nExcess  : nExcess = 120	' 120 seconds.
        Dim nSDE     : nSDE = oScan.DurationEstimate	' returned in seconds and takes account of MapScanCount.
        Dim nCountSinceLastLog: nCountSinceLastLog=0	' used to log the timing info once every 10s.

        if (nSDE &gt; 0) then
            If (nSDE / 10.0) &gt; nExcess Then nExcess = nSDE / 10.0
            Dim nMax     : nMax = nSDE + nExcess

            dim sScanDuration: sScanDuration=sTimeString(nSDE)
            Logger.Debug "Scan estimate = " &amp; sScanDuration &amp; " Used to set timeout of " _
                                            &amp; CStr(nMax) &amp; "s (" &amp; CStr(nSDE) &amp; "s plus " &amp; nExcess &amp; "s)"
            Do While (Not m_bScanComplete ) And nTime &lt;= nMax And (Not Me.Aborted) and (g_bSleeping)
                Dim nWaited: nWaited = Sleep2(nMilliseconds)
                'If the error source and description changed them same should be reflected into the respective UI test (WiREInterfaceUI\MeasurementTests)
                if (g_TestMeasurementError = 105) then  Err.Raise vbObjectError + 1, "WaitForScanComplete", "Test error 105 raised during scan"

                nCountSinceLastLog = nCountSinceLastLog + 1

                ' Don't time out if we're waiting on input triggers
                if (not bUsingTriggers) then 
                    nTime = nTime + CDbl(nWaited / 1000.0)
                    ' if we are over 10s since last log, log again. This helps to diagnose timeout issues.
                    if (nCountSinceLastLog * nMilliseconds &gt; 10000) then
                        Dim sTimeLog: sTimeLog = "Scan time update: Scan has waited "  &amp; FormatNumber(nTime + (nMax * nOverrun), 0) &amp; "s of an estimated " &amp; CStr(nMax) &amp; _
                                     "s; timeout = " &amp; CStr(nLimit) &amp; " * " &amp; CStr(nMax) &amp; " = " &amp; CStr(nLimit*nMax)
                        ' if we are in the overrun then log this as a warning...
                        if (nOverrun &lt; 1) then
                            Logger.Debug sTimeLog
                        else
                            Logger.Warn sTimeLog
                        end if
                        nCountSinceLastLog = 0
                    end if
                end if

                'Activity CStr(System.SequenceStatusAsString(-1))
                If nTime &gt; nMax Then
                    sErr = "Exceeded scan duration estimate of " &amp; CStr(nMax) &amp; "s. Overrun = " &amp; CStr(nOverrun+1) &amp; " of " &amp; CStr(nLimit) 
                    Activity FormatMessage("Exceeded scan duration estimate of " &amp; CStr(nMax) &amp; "s.")
                    Logger.Warn sErr
                    If nOverrun &lt; nLimit Then 
                        nTime = 0
                        nOverrun = nOverrun + 1
                    end if
                End If
            Loop
        end if

        ' Stop focus tracking at the end of the scan
        If Scan.UsePAF Then
            Logger.Log "Measurement calling StopPAFTracking after scan..."
            Scan.StopPAFTracking False ' False means don't disconnect PAF after stopping
        End If

        If m_bMaximizeWhitelight Then Instrument.ApplyWhitelight true, ImageCapture.IlluminationLampBrightness
        If Me.Aborted Then
            Logger.Debug "Scan aborted while waiting for scan to complete (" _
                &amp; CStr(nTime) &amp; " s with max " &amp; CStr(nLimit * nMax) &amp; " s)"
        ElseIf Not m_bScanComplete Then 
            Logger.Error "Timeout expired waiting for scan to complete (" _
                &amp; CStr((nOverrun*nMax) + nTime) &amp; " s with max " &amp; CStr(nLimit * nMax) &amp; " s) [ = " &amp; CStr(nLimit) &amp; " * " &amp; Cstr(nMax) &amp; "]."
        ElseIf m_eMode = eInteruptedSeries or m_eMode = eCustomSeries Then
            Logger.Debug "Scan completed after " &amp; CStr(nTime) &amp; " s with max " &amp; CStr(nLimit * nMax) &amp; " s"
            ' now do the scan complete stuff

            If m_oImageCapture.CaptureMode &gt; 1 Then
                m_oImageCapture.GrabImage 2, True ' capture the post image
            End If

            'Update the pre and/or post image for specified acquisition
            If m_oImageCapture.CaptureMode &gt; 0 Then
                m_oImageCapture.UpdateDataset
            End If

            Call WaitForContinueMeasurement
        Else
            Logger.Debug "Map scan completed after " &amp; CStr((nOverrun*nMax) + nTime) &amp; " s with max " &amp; CStr(nLimit * nMax) &amp; " s"
        End If
    End Sub

    Public function IsScanRunning
        IsScanRunning = Not m_bScanComplete
    End function

    Private Sub DisconnectFocusTrack
        on error resume next    ' we don't worry if this fails
        Logger.Debug "Disconnecting focustrack from system object"
        If IsObject(FocusTrack) And Not(FocusTrack Is Nothing) Then
            FocusTrack.ReleaseSystem
        End If
        Err.Clear
    End Sub

    ' Pause the multi-sequence operation and wait in a sleep loop for the "continueMeasurement" flag to be set
    Private Sub WaitForContinueMeasurement
    If (m_eType and eThermal2) &lt;&gt; eThermal2 Then
        Dim bContinue: bContinue = False
        Dim bMSOPaused: bMSOPaused = False
        On Error Resume Next
        bContinue = Measurement.Properties("continueMeasurement")
        If Err.Number &lt;&gt; 0 Then bContinue = True    ' flag not present so continue
        On Error Goto 0
        If bContinue = False Then 
            Logger.Log "Pausing multi-sequence operation while measurement sleeps"
            m_oMSO.Halt
            bMSOPaused=True
        End If
        
        Dim nFailCount: nFailCount = 0    ' Seem to get some failures while other objects access result file
        Do While Not (bContinue Or Me.Aborted Or nFailCount &gt; 4)
        On Error Resume Next
        bContinue = Measurement.Properties("continueMeasurement")
        If Err.Number = 0 Then 
            nFailCount = 0
        Else
            nFailCount = nFailCount + 1
            Logger.Warn "Unexpected failure reading continueMeasurement " &amp; CStr(nFailCount)
        End If
        On Error Goto 0
        Sleep 100
        Loop
        If bMSOPaused Then 
        Logger.Log "Restarting multi-sequence operation following measurement sleep"
        m_oMSO.Start
        End If
    End If
    End Sub

    ' Modify the passed-in scan to reduce the exposure time by half or if this is not possible knock down the 
    ' instrument state ND filter value one notch.  In the latter case we also need to apply the instrument 
    ' state.  Set the CAquisition member variables m_bSaturationMod = True and m_lSaturationExpTime, 
    ' m_dSaturationNDPercent to the new values subsequently logged to the resulting (unsaturated) dataset
    Public Sub ModifyForSaturationProtection(oScan)
        m_bSaturationMod = False
        Dim lMinExpTime: lMinExpTime = 1        ' 100 ms min exposure time for static scans
        If (oScan.ScanType = WIRESCAN2Lib.eWST_CONTINUOUS_GRATING_SCAN  Or oScan.ScanType = WIRESCAN2Lib.eWST_CONTINUOUS_GRATING_IMAGE) Then 
            ' For continuous extended scans we read the min time from the grating object
            lMinExpTime = 10000
            If Not (Instrument Is Nothing) Then lMinExpTime = Instrument.GratingMinExposureTime
        End If
        Dim lNewExpTime: lNewExpTime = CLng(oScan.ExpTimeInMillSecs / 2)
        If lNewExpTime &gt;= lMinExpTime Then
            m_lSaturationExpTime = lNewExpTime
            oScan.ExpTimeInMillSecs = lNewExpTime
            Logger.Log "Saturation protection - exposure time modified to " &amp; CStr(lNewExpTime) &amp; " ms"
            m_bSaturationMod = True
        Else
            ' Already close to min exposure time - have to mod ND value
            If Not(Instrument Is Nothing) Then 
                Dim dLowerNDValue: dLowerNDValue = Instrument.NextLowerNDPercent
                If dLowerNDValue &lt;&gt;0 Then
                    m_bScanComplete = False
                    ' NextLowerNDPercent succeeded - set in instrument state and apply
                    m_dSaturationNDPercent = dLowerNDValue
                    InstrumentState.NDPercent = dLowerNDValue
                    Instrument.ApplyLampsAndMotors
                    Logger.Log "Saturation protection - ND percent modified to " &amp; CStr(dLowerNDValue) &amp; "%"
                    m_bScanComplete = True
                    m_bSaturationMod = True
                End If
            End If
        End If
    End Sub
    
    Public Sub AddSaturationProtectionDetails (oDict) 
        oDict.Add "UnsaturatedNDPercent", m_dSaturationNDPercent
        oDict.Add "UnsaturatedExposureTime", m_lSaturationExpTime
        oDict.Add "SaturationProtectionUsed", m_bSaturationMod
    End Sub

    ' Intent: Check all datasets (may be multitrack) for hitting the ADC saturation threshold which we 
    ' (conservatively) will assume is 60,000.  Assume the minimum of start and end pixel size 
    ' in cm-1 and the appropriate # e- / count for the camera gain (high = 2.5; low = 10).
    '
    ' Actual implementation: checks the dataSaturated flag set by the scan.
    ' The threshold where this is tripped is the WiREDebugFlag "SaturationThreshold" 
    '   which defaults to 65535.
    Private Function CheckDataForSaturation(oMemoryFile)
        CheckDataForSaturation = False
        Dim nDataSetIndex, sDataSet: sDataSet = "DataSet0"
        Dim lNumLists: lNumLists = oMemoryFile.NumberOfDataLists(sDataSet)

        ' For each dataset in the collectedDatasets check whether any have intensity values &gt; saturation threshold
        dim oCollectedDatasets: set oCollectedDatasets = oMemoryFile.Element("","collectedDatasets")
        dim nCollectedDataset
        if IsObject(oCollectedDatasets) And Not(oCollectedDatasets Is Nothing) then
            Logger.Log "Saturation threshold checking Datasets " &amp; CStr(m_LastDatasetCount) &amp; " to " &amp; CStr(oCollectedDatasets.Count - 1)
            For nDataSetIndex = m_LastDatasetCount to oCollectedDatasets.Count - 1
                dim bSat: bSat = false
                on error resume next
                    bSat = oMemoryFile.Element("DataSet" &amp; CStr(nDataSetIndex), "DataSaturated")
                On Error GoTo 0
                if bSat = true then
                    CheckDataForSaturation = True
                    Logger.Log "Saturation threshold check: returned TRUE"
                    Exit For
                End If
            Next
        End If
    End Function

End Class

' -------------------------------------------------------------------------
' Instrument Initialization
' -------------------------------------------------------------------------
'

Class CInstrument
    Private m_oInstrumentState
    Private m_nStateApplied
    Private m_vCalibrationState
    Private m_vInstrumentState
    Private m_bRunSilent

    Private Sub Class_Initialize()
        m_nStateApplied = -1
    End Sub

    Public Sub Init(oInstrumentState, oSystem, bRunSilent)
        ' Check that the Instrument State object is initialised with a useful area key.
        ' If not, use the systems current area key.
        Set m_oInstrumentState = oInstrumentState
        m_oInstrumentState.System = oSystem
        m_bRunSilent = bRunSilent
        If m_oInstrumentState.AreaKey.LaserName = "" Then
            m_oInstrumentState.AreaKey = oSystem.AreaKey
        End If
        m_oInstrumentState.ParentHWND = g_parentHWND
    End Sub
    
    ' ModPodulePathForLiveTrack MUST be called after this.Init has been called.  
    Public Sub ModPodulePathForLiveTrack (bUseLiveTrack)
        if bUseLiveTrack = true And m_oInstrumentState.PodulePath = ePWC_LASER_SAMPLE then
            m_oInstrumentState.PodulePath = ePWC_LIVETRACK_PLUS_RAMAN
            Logger.Log "Measurement script forced podule path to ePWC_LIVETRACK_PLUS_RAMAN because Measurement.Properties('PAFEnabled') == true "
        end if        
    End Sub

    Public Sub Apply()
        ' Apply the Instrument State and wait for it to complete
        Activity FormatMessage("Applying instrument state")
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.Apply pre"
        WaitForIdleInstrument 250, "CInstrument.Apply"
        m_nStateApplied = -1 : g_InstrumentStateApplied = -1
        m_oInstrumentState.RunSilent = m_bRunSilent
        m_oInstrumentState.ApplyAll
        WaitForInstrumentState 250
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.Apply post"
    End Sub
    
    ' returns the logical position of the current motor
    public function CurrentMotorPos(eMtr)
        CurrentMotorPos = 0
        Dim oMotor

        on error resume next
        Dim oPodule: Set oPodule = m_oInstrumentState.System.HostedObject(eSHO_PODULE)
        Set oMotor = oPodule.GetCurrentMotor(eMtr)  ' fails if eMtr is not a podule or FOP motor
        if err.number &lt;&gt; 0 then 
            ' so we are here if the Podule know notihng about this motor.
            err.Clear   
            
            Dim oMotors: Set oMotors = m_oInstrumentState.System.HostedObject(eSHO_MOTOR_COLLECTION)
            Set oMotor = oMotors.GetMotorByEnum(eMtr)
        end if
        CurrentMotorPos = oMotor.MotorPositionInUnits
        on error goto 0
    end function

    ' returns the motor name for the passed in logical position.    
    public function NamedMotorPos(eMtr, mtrPosition)
        NamedMotorPos = ""
        Dim oMotor

        on error resume next
        Dim oPodule: Set oPodule = m_oInstrumentState.System.HostedObject(eSHO_PODULE)
        Set oMotor = oPodule.GetCurrentMotor(eMtr)  ' fails if eMtr is not a podule or FOP motor
        if err.number &lt;&gt; 0 then 
            ' so we are here if the Podule know notihng about this motor.
            err.Clear   
            
            Dim oMotors: Set oMotors = m_oInstrumentState.System.HostedObject(eSHO_MOTOR_COLLECTION)
            Set oMotor = oMotors.GetMotorByEnum(eMtr)
        end if

        Dim oNamedPositions: Set oNamedPositions = oMotor.MotorNamedPositions
        NamedMotorPos = oNamedPositions.Key(mtrPosition)
        on error goto 0
    end function

    Public Sub ApplyForImageCapture(bIlluminationLampOn, nLampBrightness)
        Dim oPodule: Set oPodule = m_oInstrumentState.System.HostedObject(eSHO_PODULE)
        Dim oPoduleParams: Set oPoduleParams = oPodule.GetPodParamsFromKey(oPodule.PoduleParamsCurrentKey)
        if oPoduleParams.PoduleClass = eWPC_FOP then
            ApplyForImageCapture_FOP bIlluminationLampOn, nLampBrightness
        else 
            if oPoduleParams.PoduleClass = eWPC_PODULE then
                ApplyForImageCapture_Podule bIlluminationLampOn, nLampBrightness
            end if
        end if
    End Sub
    
    private Sub ApplyForImageCapture_FOP(bIlluminationLampOn, illuminationLampIntensity)
        Dim fopPos : fopPos = m_oInstrumentState.FOPMirrorPos   ' preserve the FOP pos
        Dim bLampState : bLampState = m_oInstrumentState.IlluminationLampOn ' preserve the lamp setting
        Dim nIntensity : nIntensity = m_oInstrumentState.IlluminationLampIntensity ' preserve current lamp brightness

        m_oInstrumentState.PodulePath = WIREPODULELib.ePWC_EYE_PIECES_SAMPLE_VIDEO
        m_oInstrumentState.IlluminationLampOn = bIlluminationLampOn
        m_oInstrumentState.IlluminationLampIntensity = illuminationLampIntensity

        ' Apply the Instrument State and wait for it to complete
        ApplyAndWait "CInstrument.ApplyForImageCapture(FOP)"

        m_oInstrumentState.FOPMirrorPos = fopPos            ' restore the FOP pos
        m_oInstrumentState.IlluminationLampOn = bLampState  ' restore the lamp setting
        m_oInstrumentState.IlluminationLampIntensity = nIntensity ' restore the lamp brightness
    End Sub

    private sub ApplyAndWait(sourceMsg)
        Activity FormatMessage("Applying instrument state")
        WaitForIdleSystem m_oInstrumentState.System, 250, sourceMsg + " pre"
        WaitForIdleInstrument 250, sourceMsg 
        m_nStateApplied = -1 : g_InstrumentStateApplied = -1
        m_oInstrumentState.ApplyAll
        WaitForInstrumentState 250
        WaitForIdleSystem m_oInstrumentState.System, 250, sourceMsg + " post"
    End sub

    private Sub ApplyForImageCapture_Podule(bIlluminationLampOn, illuminationLampIntensity)
        Dim nPoduleUpper : nPoduleUpper = m_oInstrumentState.PoduleUpperWheel   ' preserve current wheel pos
        Dim nPoduleLower : nPoduleLower = m_oInstrumentState.PoduleLowerWheel   ' preserve current wheel pos
        Dim bLampState : bLampState = m_oInstrumentState.IlluminationLampOn     ' preserve current lamp setting
        Dim nIntensity : nIntensity = m_oInstrumentState.IlluminationLampIntensity ' preserve current lamp brightness

        ' check to see if we're on the magic 5% beamsplitter that is supposed to be there (a SPECIAL)
        m_oInstrumentState.PoduleUpperWheel = CurrentMotorPos(eWMO_PODULE_UPPER_SELECTOR_WHEEL)
        m_oInstrumentState.PoduleLowerWheel = CurrentMotorPos(eWMO_PODULE_LOWER_SELECTOR_WHEEL)
        if LCase(NamedMotorPos(eWMO_PODULE_LOWER_SELECTOR_WHEEL, nPoduleLower)) &lt;&gt; _
                    LCase("5% Beamsplitter") then
            ' select Eye Piece / 50% Sample
            m_oInstrumentState.PodulePath = WIREPODULELib.ePWC_EYE_PIECES_SAMPLE_VIDEO
        End if
        m_oInstrumentState.IlluminationLampOn = bIlluminationLampOn
        m_oInstrumentState.IlluminationLampIntensity = illuminationLampIntensity

        ' Apply the Instrument State and wait for it to complete
        ApplyAndWait "CInstrument.ApplyForImageCapture(Podule)"
            
        m_oInstrumentState.PoduleUpperWheel = nPoduleUpper  ' restore the wheel pos
        m_oInstrumentState.PoduleLowerWheel = nPoduleLower  ' restore the wheel pos
        m_oInstrumentState.IlluminationLampOn = bLampState  ' restore the lamp setting
        m_oInstrumentState.IlluminationLampIntensity = nIntensity ' restore the lamp brightness
    End Sub
    
    Public Sub CloseShutter
        m_oInstrumentState.ShutterOpen = False
        ApplyShutter
    End Sub

    Public Sub OpenShutter
        m_oInstrumentState.ShutterOpen = True
        ApplyShutter
    End Sub

    Public Sub ApplyShutter
        Activity FormatMessage("Operating laser shutter")
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.ApplyShutter pre"
        WaitForIdleInstrument 250, "CInstrument.ApplyShutter"
        m_nStateApplied = -1 : g_InstrumentStateApplied = -1
        m_oInstrumentState.ApplyShutter
        WaitForInstrumentState 250
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.ApplyShutter post"
    End Sub

    Public Sub ApplyAreaKey()
        ' Apply the Instrument State'a area key only and wait for it to complete
        Activity FormatMessage("Applying instrument state's areakey")
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.ApplyAreaKey"
        WaitForIdleInstrument 250, "CInstrument.ApplyAreaKey"
        ' applyareakey is synchrnous and does not wait for a sequence complete message.
        m_oInstrumentState.ApplyAreaKey
    End Sub
    
    'For inverted microscopes, they might want to do image capture 
    '   with the podule in the correct position but the illumination lamp OFF.
    ' Therefore the state of the lamp is passed in as a parameter
    Public Sub ApplyWhitelight(bIlluminationLampOn, nLampIntensity)
        Dim oPodule: Set oPodule = m_oInstrumentState.System.HostedObject(eSHO_PODULE)
        Dim oPoduleParams: Set oPoduleParams = oPodule.GetPodParamsFromKey(oPodule.PoduleParamsCurrentKey)
        if oPoduleParams.PoduleClass = eWPC_FOP then
            ApplyWhitelight_FOP bIlluminationLampOn, nLampIntensity
        else 
            if oPoduleParams.PoduleClass = eWPC_PODULE then
                ApplyWhitelight_Podule bIlluminationLampOn, nLampIntensity
            end if
        end if
    End Sub

    private Sub ApplyWhitelight_Podule(bIlluminationLampOn, nLampIntensity)
        Dim nPoduleUpper : nPoduleUpper = m_oInstrumentState.PoduleUpperWheel
        Dim nPoduleLower : nPoduleLower = m_oInstrumentState.PoduleLowerWheel
        Dim bLampState : bLampState = m_oInstrumentState.IlluminationLampOn
        Dim nIntensity : nIntensity = m_oInstrumentState.IlluminationLampIntensity

        ' Lower podule wheel in position 4 indicates 5% beamsplitter for Roche.
        ' In this position we do not want to move the podule for more white light
        ' as the video settings have been adjusted to cope. With the Mk2 podule
        ' this position is the internal calibration source, but as noone is going to run
        ' a measurement of the internal calibration source while collecting
        ' white light images of the sample, it's unlikely to be a problem.
        m_oInstrumentState.PoduleUpperWheel = CurrentMotorPos(eWMO_PODULE_UPPER_SELECTOR_WHEEL)
        m_oInstrumentState.PoduleLowerWheel = CurrentMotorPos(eWMO_PODULE_LOWER_SELECTOR_WHEEL)

        if LCase(NamedMotorPos(eWMO_PODULE_LOWER_SELECTOR_WHEEL, nPoduleLower)) &lt;&gt; _
                    LCase("5% Beamsplitter") then
            ' select Eye Piece / 50% Sample
            m_oInstrumentState.PodulePath = WIREPODULELib.ePWC_EYE_PIECES_SAMPLE_VIDEO
        end if
        m_oInstrumentState.IlluminationLampOn = bIlluminationLampOn
        m_oInstrumentState.IlluminationLampIntensity = nLampIntensity

        On Error Resume Next
            Me.ApplyLampsAndMotors
            If Err.Number &lt;&gt; 0 Then Logger.Error "Failed to switch to white-light view: " &amp; Err.Description
        On Error Goto 0
        
        m_oInstrumentState.PoduleUpperWheel = nPoduleUpper
        m_oInstrumentState.PoduleLowerWheel = nPoduleLower
        m_oInstrumentState.IlluminationLampOn = bLampState
        m_oInstrumentState.IlluminationLampIntensity = nIntensity
    End Sub

    private Sub ApplyWhitelight_FOP(bIlluminationLampOn, nLampIntensity)
        
        Dim fopPos : fopPos = m_oInstrumentState.FOPMirrorPos   ' preserve the FOP pos
        Dim bLampState : bLampState = m_oInstrumentState.IlluminationLampOn
        Dim nIntensity : nIntensity = m_oInstrumentState.IlluminationLampIntensity

        m_oInstrumentState.PodulePath = WIREPODULELib.ePWC_EYE_PIECES_SAMPLE_VIDEO
        m_oInstrumentState.IlluminationLampOn = bIlluminationLampOn
        m_oInstrumentState.IlluminationLampIntensity = nLampIntensity

        On Error Resume Next
            Me.ApplyLampsAndMotors
            If Err.Number &lt;&gt; 0 Then Logger.Error "Failed to switch to white-light view: " &amp; Err.Description
        On Error Goto 0
        
        m_oInstrumentState.FOPMirrorPos = fopPos            ' restore the FOP pos
        m_oInstrumentState.IlluminationLampOn = bLampState  ' restore the lamp setting
        m_oInstrumentState.IlluminationLampIntensity = nIntensity
    End Sub

    Public Sub ApplyAllWhitelight(nLampIntensity)
        Dim nPoduleUpper : nPoduleUpper = m_oInstrumentState.PoduleUpperWheel
        Dim nPoduleLower : nPoduleLower = m_oInstrumentState.PoduleLowerWheel
        Dim fopPos : fopPos = m_oInstrumentState.FOPMirrorPos 
        Dim bLampState : bLampState = m_oInstrumentState.IlluminationLampOn

        ' select Eye Piece / 50% Sample
        m_oInstrumentState.PodulePath = WIREPODULELib.ePWC_EYE_PIECES_SAMPLE_VIDEO
        m_oInstrumentState.IlluminationLampOn = True
        m_oInstrumentState.IlluminationLampIntensity = nLampIntensity

        On Error Resume Next
            Me.Apply
            If Err.Number &lt;&gt; 0 Then Logger.Error "Failed to switch to white-light view: " &amp; Err.Description
        On Error Goto 0

        m_oInstrumentState.PoduleUpperWheel = nPoduleUpper
        m_oInstrumentState.PoduleLowerWheel = nPoduleLower
        m_oInstrumentState.FOPMirrorPos = fopPos            ' restore the FOP pos
        m_oInstrumentState.IlluminationLampOn = bLampState    
    End Sub

    Public Sub ApplyLampsAndMotors()
        ' Apply the Instrument State and wait for it to complete
        Activity FormatMessage("Applying instrument state for lamps and motors")
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.ApplyLampsAndMotors pre"
        WaitForIdleInstrument 250, "CInstrument.ApplyLampsAndMotors"
        m_nStateApplied = -1 : g_InstrumentStateApplied = -1
		m_oInstrumentState.ApplyLampsAndMotors
        WaitForInstrumentState 250
        WaitForIdleSystem m_oInstrumentState.System, 250, "CInstrument.ApplyLampsAndMotors post"
    End Sub

    Public Sub Record()
        ' record the current state for the result file.
        Activity FormatMessage("Recording current instrument state")
        Logger.Debug "Begin record instrument state"
        Dim oInstrumentState
        Set oInstrumentState = m_oInstrumentState.System.HostedObject(eSHO_INSTRUMENT_STATE)
        oInstrumentState.System = m_oInstrumentState.System
        oInstrumentState.AreaKey = m_oInstrumentState.System.AreaKey
        On Error Resume Next
            Set m_vInstrumentState = oInstrumentState.ReadInstrumentState 
            If Err.Number &lt;&gt; 0 Then Logger.Error "Recording instrument state: " &amp; Err.Description
            Set m_vCalibrationState = oInstrumentState.ReadCalibrationState
            If Err.Number &lt;&gt; 0 Then Logger.Error "Recording calibration state: " &amp; Err.Description
        On Error Goto 0
        Logger.Debug "End record instrument state"
    End Sub

    Public Sub WaitForIdleSystem(oSystem, nMilliseconds, sParentName)
        Dim nTime: nTime = 0
        Dim nMax : nMax =  300000 ' 5 minutes
        Logger.Debug "Waiting for System to be Idle : " &amp; CStr(sParentName)
        'Dim oSystem
        'Set oSystem = m_oInstrumentState.System
        Do While oSystem.IsSequenceRunning And nTime &lt; nMax
            Dim nWaited: nWaited = Sleep2(nMilliseconds)
            nTime = nTime + CLng(nWaited)
        Loop
        If oSystem.IsSequenceRunning Then 
            Logger.Error "Timeout expired while waiting for system to be idle (" _
                &amp; nTime &amp; " ms with max " &amp; nMax &amp; " ms)"
        Else
            Logger.Debug "System Idle after " &amp; CStr(nTime) &amp; " nTime : " &amp; CStr(sParentName)
        End If
    End Sub


    Sub WaitForInstrumentState(nMilliseconds)
        Dim nTime: nTime = 0
        Dim nMax : nMax =  300000 ' 5 minutes
        Dim nWaited: nWaited = 0
        Logger.Debug "Waiting for Instrument state to be applied"
        Do While (g_InstrumentStateApplied &lt; 0 Or m_oInstrumentState.Ready = false) And nTime &lt; nMax
            nWaited = Sleep2(nMilliseconds)
            nTime = nTime + CLng(nWaited)
        Loop
        m_nStateApplied = g_InstrumentStateApplied
        If m_nStateApplied &lt; 0 Then 
            Logger.Error "Timeout expired while applying instrument state (" _
                &amp; nTime &amp; " ms with max " &amp; nMax &amp; " ms)"
        ElseIf m_nStateApplied = 0 Then
            Logger.Debug "Instrument state applied. Status " &amp; m_nStateApplied
        Else
            Err.Raise vbObjectError + m_nStateApplied, _
                "StdMeasurement_ApplyInstrumentState", "User aborted during application of instrument state."
        End If
    End Sub

    Public Sub WaitForIdleInstrument(nMilliseconds, sParentName)
        Dim nTime: nTime = 0
        Dim nMax : nMax =  300000 ' 5 minutes
        Dim nWaited: nWaited = 0
        Logger.Debug "Waiting for idle instrument : " &amp; CStr(sParentName)
        Do While Not(m_oInstrumentState.Ready) And nTime &lt; nMax
            nWaited = Sleep2(nMilliseconds)
            nTime = nTime + CLng(nWaited)
        Loop
        Logger.Debug "Finished waiting for idle instrument after " &amp; CStr(nTime) &amp; ": " &amp; CStr(sParentName)
    End Sub

    Public Property Let StateApplied(nStatus)
        If m_nStateApplied &lt;&gt; nStatus Then
            m_nStateApplied = nStatus
        End If
    End Property
    Public Property Get StateApplied()
        StateApplied = m_nStateApplied
    End Property

    Public Function GratingMinExposureTime()
        Dim oSystem: Set oSystem = m_oInstrumentState.System
        Dim oAreaKey: Set oAreaKey = oSystem.AreaKey
        Dim oGratings: Set oGratings = oSystem.GratingCollection
        Dim oGrating: Set oGrating = oGratings.Item(oAreaKey.GratingName)
        GratingMinExposureTime = oGrating.MinimumExposureTime
    End Function

    Public Function NextLowerNDPercent()
        NextLowerNDPercent = 0    ' Default to 0 =&gt; client should interpret 0 as failed
        Dim oSystem: Set oSystem = m_oInstrumentState.System
        Dim oAreaKey: Set oAreaKey = oSystem.AreaKey
        Dim oNDFilters: Set oNDFilters = oSystem.HostedObject(WIRESYSTEMLib.eSHO_NDFILTERS)
        Dim vNDSettings: vNDSettings = oNDFilters.GetAvailableNDPercentsForLaser2(oAreaKey.LaserName, true)
        Dim dCurrentND: dCurrentND = m_oInstrumentState.NDPercent
        ' Go though the ND values until the current value is identified
        Dim i, lIndex: lIndex = -1
        For i = LBound(vNDSettings) To UBound(vNDSettings)
            If CDbl(vNDSettings(i)) = dCurrentND Then 
                lIndex = i 
                Exit For
            End If
        Next
        If lIndex &gt; LBound(vNDSettings) Then 
            lIndex = lIndex - 1
            NextLowerNDPercent = vNDSettings(lIndex)
        Else
            Logger.Warn "CInstrument::NextLowerNDPercent - failed to determine next lower ND value"
        End If
    End Function
    
    Public Function LaserWavenumber()
        Dim oSystem: Set oSystem = m_oInstrumentState.System
        LaserWavenumber = oSystem.CurrentLaserWavenumber
    End Function

    Public Property Get InstrumentState() : Set InstrumentState = m_vInstrumentState: End Property
    Public Property Get CalibrationState() : Set CalibrationState = m_vCalibrationState: End Property
End Class

' -------------------------------------------------------------------------
' Initialize the grating start up position.
'
' This is done separately from the remaining instrument state work because it can
' potentially take a very long time if the instrument has a slow grating motor.
'    NB - the areakey must have been previously applied for the 
'           calibration parameters to be correct.
' -------------------------------------------------------------------------
Private g_nGratingMotorInitialized

Private Sub InitializeGrating
    If InstrumentState.AreaKey.BeamPathKey = eBEAMPATH_GRATING Then
        Dim oGrating : Set oGrating = System.HostedObject(eSHO_CURRENT_GRATING)    
        If oGrating.IsMotorAttached Then

            Dim oGratingMotor : Set oGratingMotor = oGrating.IMotor
            Dim bGratingMovedRequired: bGratingMovedRequired = false
            If oGratingMotor.IsMotorPresent Then

                Dim dTarget
                On Error Resume Next
                    dTarget = Scan.CentreXAxisValue
                    If Err.Number &lt;&gt; 0 Then dTarget = Scan.FirstXAxisValue
                On Error Goto 0
                dTarget = ConvertToWaveNumber(dTarget, Scan.ScanToFileHandlerUnits(Scan.UserUnits))
                Dim oCurrentPos, oTargetPos
                oCurrentPos = oGratingMotor.MotorPosition
                oTargetPos = oGrating.GetMotorPosition( dTarget, 0 )

                if oCurrentPos &lt;&gt; oTargetPos then 
                    MoveGratingMotor oGrating, oGratingMotor, dTarget
                End if

           End If    ' grating present ?
       End If        ' motor attached to grating ?
   End If
End Sub


Private Sub MoveGratingMotor(oGrating, oGratingMotor, dTargetWavenumber)

    Dim oProgram : Set oProgram = CreateObject("Renishaw.WiREUSBProgramCom")
    oGrating.Add2prog_MoveGratingToWavenumber dTargetWavenumber, 0, oProgram
    oGratingMotor.Add2prog_WaitOnMotor oProgram
    
    g_nGratingMotorInitialized = -1
    Activity FormatMessage("Initializing grating to %1 /cm", FormatNumber(dTargetWavenumber))

    Dim oInstrument : Set oInstrument = New CInstrument
    oInstrument.WaitForIdleSystem System, 250, "InitializeGrating"
    System.RunNamedSequence 0, 0, "InitializeGratingMotor", oProgram
    Set oInstrument = Nothing
	
    Dim nTime, nMax, nMilliseconds
    nTime = 0 : nMilliseconds = 250 : nMax = 3600000 ' 1 hour
    Do While (g_nGratingMotorInitialized &lt; 0) And nTime &lt; nMax
        Dim nWaited: nWaited = Sleep2(nMilliseconds)
        nTime = nTime + CLng(nWaited)
    Loop
    If g_nGratingMotorInitialized = 2 Then
        Measurement.WdfProperties("WiREData").Item("ScanCompletionStatus") = "Aborted"
        Err.Raise vbObjectError + g_nGratingMotorInitialized, _
                    "StdMeasurement_InitializeGrating", "User aborted during grating motor initialization"
    ElseIf g_nGratingMotorInitialized &lt;&gt; 0 Then
        Measurement.WdfProperties("WiREData").Item("ScanCompletionStatus") = "Failed"
        Err.Raise vbObjectError + g_nGratingMotorInitialized, _
                    "StdMeasurement_InitializeGrating", "Failure during grating motor initialization"
    End If
    Activity FormatMessage("Grating motor initialized to %1 /cm", FormatNumber(dTargetWavenumber))
End Sub

Private g_nMoveFixedZPositionState

' Create a sequence to move the z-motor and wait for it to complete
' then send the sequence to the instrument and wait for it to finish.
Private Sub MoveZMotorToFixedPosition (fixedPosn)
    Dim oProgram : Set oProgram = CreateObject("Renishaw.WiREUSBProgramCom")
    Dim oMotors: Set oMotors = System.HostedObject(eSHO_MOTOR_COLLECTION)
    Dim oMotor: Set oMotor = oMotors.GetMotorByEnum(eWMO_STAGE_Z_AXIS)

    oMotor.Add2prog_GotoLogicalPosition fixedPosn, oProgram
    oMotor.Add2prog_WaitOnMotor oProgram

    g_nMoveFixedZPositionState = -1

    Dim oInstrument : Set oInstrument = New CInstrument
    oInstrument.WaitForIdleSystem System, 250, "MoveFixedZPosition"
    System.RunNamedSequence 0, 0, "MoveFixedZPosition", oProgram
    Set oInstrument = Nothing
	
    Dim nTime, nMax, nMilliseconds
    nTime = 0 : nMilliseconds = 250 : nMax = 3600000 ' 1 hour
    Do While (g_nMoveFixedZPositionState &lt; 0) And nTime &lt; nMax
        Dim nWaited: nWaited = Sleep2(nMilliseconds)
        nTime = nTime + CLng(nWaited)
    Loop
    If g_nMoveFixedZPositionState = 2 Then
        Measurement.WdfProperties("WiREData").Item("ScanCompletionStatus") = "Aborted"
        Err.Raise vbObjectError + g_nMoveFixedZPositionState, _
                    "StdMeasurement_MoveFixedZPosition", "User aborted while moving z motor to fixed position"
    ElseIf g_nMoveFixedZPositionState &lt;&gt; 0 Then
        Measurement.WdfProperties("WiREData").Item("ScanCompletionStatus") = "Failed"
        Err.Raise vbObjectError + g_nMoveFixedZPositionState, _
                    "StdMeasurement_MoveFixedZPosition", "Failure while moving z motor to fixed position"
    End If
End Sub

' Look for UseFixedZ measurement property. If it exists then move the z-motor to the
' required position, otherwise just continue the measurement at the current height.
Private Sub MoveToFixedZPosition
    Dim useFixedPosn : useFixedPosn = false
    Dim fixedPosn : fixedPosn = 0.0

    On Error Resume Next
    Err.Clear
    fixedPosn = CDbl(Measurement.Properties("UseFixedZ"))
    if Err.Number = 0 then useFixedPosn = true
    Err.Clear
    On Error Goto 0

    If useFixedPosn Then
        MoveZMotorToFixedPosition fixedPosn
    End If
End Sub

'
' ModPodulePathForMicroscope
'   checks the current microscope's podule path to see if we 
'   need to override the default path for the 'external' path.
' If so, then the InstrumentState object has its path changed.
' main usage : dual microscope systems.
'
' This function was provided for the first generation of the 
'   microscope swap functionality. This was driven by the 'PodulePath' field on the
'   microscope object. This has now been deprecated in favour of the podule's
'    "this podule requires other podules to use the external path" flag.
'   Therefore this function should now be obsolete (the microscope swap UI states that 
'   the microscope.PodulePath is obsoleted). But I didn't quite have the conviction to delete it 
'   hence making it ignored unless the debug flag "UseLegacyPodulePath" is set
'
Private sub ModPodulePathForMicroscope (oInstrumentState, oSystem)
    
    if WiREDebugFlag("UseLegacyPodulePath", false) = true then
    
        On error resume next
        Dim oMicroscope: Set oMicroscope = GetMicroscope(oSystem)
        If IsObject(oMicroscope) And Not(oMicroscope Is Nothing) Then
            ' only override the podule path if it is the default.
            if oInstrumentState.PodulePath = WIREPODULELib.ePWC_LASER_SAMPLE Then
                if oMicroscope.PodulePath &lt;&gt; WIREPODULELib.ePWC_NOTSET AND _
                   oMicroscope.PodulePath &lt;&gt; WIREPODULELib.ePWC_NULL AND _
                   oMicroscope.PodulePath &lt;&gt; WIREPODULELib.ePWC_LASER_SAMPLE Then
                    oInstrumentState.PodulePath = oMicroscope.PodulePath
                    Logger.Log "Overriding Podule Path to " &amp; CStr(oInstrumentState.PodulePath)
                end if
            end if
        end if
        on error goto 0

    end if 

End Sub

Private Function WiREDebugFlag(debugFlagName, defaultValue)
    On Error Resume Next
        WiREDebugFlag = CBool(defaultValue)
        Dim oShell : Set oShell = CreateObject("WScript.Shell")
        WiREDebugFlag =  CBool(oShell.RegRead("HKLM\Software\Renishaw\WiRE2\Debug\" + debugFlagName))
        if err.number = 0 then
            Logger.Log "   Measurement Script read WiREDebugFlag '" + debugFlagName + "' as " + CStr(WiREDebugFlag)
        else
            Logger.Log "   Measurement Script failed to read WiREDebugFlag '" + debugFlagName + "' : setting it to the default " + CStr(WiREDebugFlag)
        end if
    On Error Goto 0
End Function

private function MicroscopeUsesExternalPath(oSystem)
    MicroscopeUsesExternalPath = false
    on error resume next
        ' if there is a microscope AND it uses the external path then return TRUE.
        Dim oMicroscope: Set oMicroscope = GetMicroscope(oSystem)
        If IsObject(oMicroscope) And Not(oMicroscope Is Nothing) Then
            if oMicroscope.PodulePath = WIREPODULELib.ePWC_EXTERNAL then _
                MicroscopeUsesExternalPath = true
        end if
    on error goto 0
end function


private function GetMicroscope(oSystem)
    on error resume next
    Set GetMicroscope = Nothing
    Dim oMicroscopes: Set oMicroscopes = oSystem.HostedObject(eSHO_MICROSCOPES)
    If IsObject(oMicroscopes) And Not(oMicroscopes Is Nothing) Then
        Set GetMicroscope = oMicroscopes.GetCurrentMicroscope()
    end if
    on error goto 0
End function



Private Function ConvertToWavenumber(dPos, eUnits)
    Dim oQ : Set oQ = CreateObject("Renishaw.WiREQueueCom")
    Dim System : Set System = oQ.Systems(0)
    Dim oArith : Set oArith = CreateObject("Renishaw.WiREArithmeticFunctionsCom")
    Dim oLasers : Set oLasers = System.HostedObject(eSHO_LASERS)
    Dim oLaser  : Set oLaser = oLasers.Item(System.AreaKey.LaserName)
    Dim dLaser  : dLaser = oLaser.Wavenumber
    ConvertToWavenumber = oArith.ConvertWavenumberUnits(dPos, eUnits, eABSOLUTE_WAVENUMBER, dLaser)
End Function

' -------------------------------------------------------------------------
' On System SequenceComplete is used to tell us that the 
' instrument state has been applied.
' Also, if any sequence is aborted it will be caught here.
' N.B. This function MUST always run, so any erros caused by accessing NULL 
'      object must be handled safely (see handling of Acquisition object).
Public Sub System_SequenceCompleteEvent2(nTerminateStatus, sSequenceName)

    if g_runningPlugIns then exit sub

    dim currentAcqStatus: currentAcqStatus = -1
    if Not(Acquisition is nothing) then 
        currentAcqStatus = Acquisition.TerminationStatus    ' cached so we don't try to access the Acquisition object when logging debug stuff
        Logger.Debug "Sequence complete received (current status = " &amp; CStr(Acquisition.TerminationStatus) &amp; _
                     "). Termination status " &amp; CStr(nTerminateStatus) &amp; ". Sequence name " &amp; sSequenceName
    else
        Logger.Debug "Sequence complete received. Termination status " &amp; CStr(nTerminateStatus) &amp; ". Sequence name " &amp; sSequenceName
    end if
    
    if IsAcquisitionRunningAScan then
        ' A scan is running. It will handle the abort and complete when it is ready
        if nTerminateStatus &lt;&gt; eWAS_OK then
            Logger.Debug "setting measurement abort status even though a scan is running. This should terminate the measurement" ' ie the scan will terminate with the abort event.
            ' in this case the Acquisition.Run must check the termination status of the scan.

            ' this will force the scan to terminate for interrupted series.
            if MmtAbortState = eWAS_OK then
                SetMmtAbortState nTerminateStatus
                if Not (Acquisition Is nothing) then Acquisition.TerminationStatus = nTerminateStatus
            end if
        else
            Logger.Debug "System_Sequence completed received during a scan; it is presumably the scan completing..." 
        end if
    else
        ' Deal with abortable sleep (time series)
        If nTerminateStatus = eWAS_USER_ABORT And g_bSleeping Then
            g_bSleeping = False
            Logger.Debug "System_SequenceCompleteEvent2 clearing g_bSleeping"
        End If

        if Not(currentAcqStatus = nTerminateStatus) then
            dim s
            s = "seqComplete upgrading acquisition. TerminateStatus(" &amp; Cstr(currentAcqStatus) &amp; ")"
            s = s &amp; " to (" &amp; Cstr(nTerminateStatus) &amp; ")"
            s = s &amp; " for seq (" &amp; Cstr(sSequenceName) &amp; ")"
            Logger.Debug s
        end if        

        If sSequenceName = "InitializeGratingMotor" Then
            g_nGratingMotorInitialized = nTerminateStatus
        ElseIf sSequenceName = "MoveFixedZPosition" Then
            g_nMoveFixedZPositionState = nTerminateStatus
        ElseIf sSequenceName = "ApplyLampsAndMotors" Or sSequenceName = "ApplyShutter" Then
            g_InstrumentStateApplied = nTerminateStatus
            if SetAcquisitionTerminationStatus_ifReqd(nTerminateStatus) then' this could have been any instState apply
                Logger.Debug "sequComplete terminating the acquisition"     '  so terminate the acquistion too.
                ' if we were aborted do we need to set the abortstate in the measurement here too ?
            else
                Logger.Debug "seqComplete " &amp; CStr(sSequenceName) &amp; _
                                " not passing abort " &amp; Cstr(nTerminateStatus) &amp; _
                                " on to the acquisition because acq.abort was already " &amp; CStr(currentAcqStatus)
            end if
        Else

            ' If we are now running scans then record the termination status    
            If Instrument Is Nothing Then
                'g_bResponseInitializationTimeout = True
                Logger.Error "Unexpected scanComplete in the measurement script"
            Else
                If Instrument.StateApplied &lt; 0 Then
                    Logger.Debug "Setting Instrument to halt (" &amp; nTerminateStatus &amp; ")."
                    g_InstrumentStateApplied = nTerminateStatus
                Else
                    if SetAcquisitionTerminationStatus_ifReqd(nTerminateStatus) then
                        Logger.Debug "Setting Acquisition to halt (" &amp; nTerminateStatus &amp; ")."
                        ' if the existing state in the measurement is eWAS_OK AND this sequence
                        ' was aborted then we need to record the abort info in the measurement result.
                        if MmtAbortState = eWAS_OK AND nTerminateStatus &lt;&gt; eWAS_OK then
                            SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT
                        End if
                    End If
                End If
            End If
        End If
        Wake
    End If
End Sub

' -------------------------------------------------------------------------
' worker functions for System_SequenceCompleteEvent2

'
' sets Acquisition.TerminationStatus to the passed in one, but first checks
'   that Acquisition is not nothing 
'   that the Acquisition is not already stopped.
public function SetAcquisitionTerminationStatus_ifReqd(nTerminateStatus)
    Dim bSet: bSet = false
    if Not (Acquisition Is Nothing) then 
        if (Acquisition.TerminationStatus = eWAS_OK or _
            Acquisition.TerminationStatus = eWAS_USER_ABORT_REQUEST) then
            Acquisition.TerminationStatus = nTerminateStatus
            bSet = true
        end if
    end if
    SetAcquisitionTerminationStatus_ifReqd = bSet
end function
 
' returns Acquisition.IsScanRunning, or false if Acquisition is null
public function IsAcquisitionRunningAScan()
    IsAcquisitionRunningAScan = false
    if Not (Acquisition Is Nothing) then
        IsAcquisitionRunningAScan = Acquisition.IsScanRunning
    end if
end function

'
' System_AbortRequest
'     Fired by the system object, initially with AbortType = AbortRequest
'    The mmtScript fires this uip to a parent object.
'    If a scan is runing then the parent has the option to display an abort dialog.
'    The abort dialog will allow the user to select AbortAtEndOfAccumulation or EndOfScan.
'    These two items cause the parent to tell the system to abort again, and we catch a
'    new abort event from the system with the appropriate AbortType parameter.
' NB    It is possible for this not to be called in some situations... If this happens then
'    the abortRequest will be upgraded to an immediate sequence abort.
Public Sub System_AbortRequest(abortType)
    Logger.Warn "In SystemAbortRequest(" &amp; CStr(abortType) &amp; ")"
    if Not Acquisition is nothing then
        Logger.Warn "In SystemAbortRequest, current state(" &amp; Cstr(Acquisition.TerminationStatus) &amp; _
            "); new abortType(" &amp; CStr(abortType) &amp; "); "
    end if 
    Dim bWasSleeping: bWasSleeping = false 
    On Error Resume Next
    if g_bMinimalScan then
        Measurement.Properties("cycling") = False
    end if

    SetMmtAbortState WIRESYSTEMLib.eWAS_OK  ' reset the abort state

    Select Case abortType
        Case WIRESYSTEMLib.eWAS_USER_ABORT
            AbortRunningPlugIns false
            if g_measurementPhase = WIREEXPERIMENT2Lib.mpMeasurement then
                ' record the abort in measurement result
                If MmtAbortState = WIRESYSTEMLib.eWAS_OK Then ' do not overwrite existing entries
                    SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT
                End If
                ' Deal with abortable sleep (time series)
                If g_bSleeping Then
                    bWasSleeping = True
                    g_bSleeping = False
                    Logger.Debug "System_AbortRequest clearing g_bSleeping"
                    if not Acquisition is nothing then
                        If (Acquisition.TerminationStatus = eWAS_OK) Then Acquisition.TerminationStatus = eWAS_USER_ABORT
                    end if
                End If

                ' Support aborting a temperature ramp.
                if Not(Acquisition is Nothing) then
                    if Not(Acquisition.TemperatureStage Is Nothing) Then
                        Logger.Debug "System_AbortRequest aborting temperature ramp"
                        Acquisition.TemperatureStage.Abort = True
                        If (Acquisition.TerminationStatus = eWAS_OK) Then Acquisition.TerminationStatus = eWAS_USER_ABORT
                    End If
            
                    ' If the scan isn't yet running, make sure we don't try to run it
                    ' actually, I think we need to set this all the time; if a scan is running then
                    '  then the TerminationStatus flag will be ready and waiting when it completes.
                    If (Acquisition.TerminationStatus = eWAS_OK) Then Acquisition.TerminationStatus = eWAS_USER_ABORT
                End if
            end if

        Case WIRESYSTEMLib.eWAS_USER_ABORT_REQUEST
            If g_AbortReqCount &gt; 2 then
                ' the user has tried to abort 3 times so clearly something is not working so lets just abort anyway.
                Logger.Warn "In SystemAbortRequest (eWAS_USER_ABORT_REQUEST) AGAIN (3 times now). Forcing abort..."
                AbortRunningPlugIns true
                SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT
            else
                ' we'll let the parent decide what to do with this. The parent can call system.SuspendAbort()
                '   in its RaiseAbortRequest handler which effectively means that the parent will take responsibility
                '   for aborting. In this case, the abort will be triggered by an abort event form the system with one  
                '   of the following termination statuses:
                '     eWAS_USER_ABORT,              - immediate abort
                '     eWAS_USER_ABORT_AFTER_ACC,    - handled in-scan
                '     eWAS_USER_ABORT_AFTER_SCAN,   - handled in this measurement script.
                Dim localScanCount: localScanCount = 0  ' temporary copy for when Acuqisition is NULL
                if Not(Acquisition is Nothing) then localScanCount = Acquisition.ScanCount
                Logger.Warn "In SystemAbortRequest (eWAS_USER_ABORT_REQUEST);  "
                dim mmtAS: mmtAS = MmtAbortState
                Measurement.RaiseAbortRequest Scan.NumOfAccumulations, localScanCount, mmtAS, g_measurementPhase
                ' note that if System.SuspendAbort was not called in the RaiseAbortRequest event handler then
                ' the system object will the abort as an abort with a status of eWAS_USER_ABORT 
                g_AbortReqCount = g_AbortReqCount+1    ' increment the number of times we've seen this.
                if System.SuspendAbort = false then
                    ' looks like the abort was not suspended - so we'll set the abort status now.
                    Logger.Error "UserAbortRequest: after Measurement.RaiseAbortRequest system.suspendAbort was still FALSE"
                    AbortRunningPlugIns false
                    if MmtAbortState = WIRESYSTEMLib.eWAS_OK then ' do not overwrite existing entries
                        SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT
                    end if
                end if
            end if

        Case WIRESYSTEMLib.eWAS_USER_ABORT_AFTER_ACC '  Abort at end of current accumulation
            Logger.Warn "In SystemAbortRequest (eWAS_USER_ABORT_AFTER_ACC) "
            System.SuspendAbort = true
            If g_bMinimalScan then
                If Not g_bMinimalScanComplete Then    ' in a scan ?
                    Scan.AbortAtEndOfAccumulation 
                Else        ' not in a scan
                    System.Abort WIRESYSTEMLib.eWAS_USER_ABORT    ' just abort
                End If
            Else
                Acquisition.StopAfterAcc
            End If

            SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT_AFTER_ACC

        Case WIRESYSTEMLib.eWAS_USER_ABORT_AFTER_SCAN ' Abort at end of current scan
            System.SuspendAbort = true
            if MmtAbortState = WIRESYSTEMLib.eWAS_USER_ABORT_AFTER_ACC then
                ' this should be impossible.
                Logger.Error "AbortAfterScan called when state was already AbortAfterAcc"
            else
                Logger.Warn "In SystemAbortRequest (eWAS_USER_ABORT_AFTER_SCAN) "
                if not g_bMinimalScan then
                    Acquisition.StopAfterScan
                end if
                
                SetMmtAbortState WIRESYSTEMLib.eWAS_USER_ABORT_AFTER_SCAN
            end if
        
        Case Else
            ' ignore
    End Select 
    If Err.Number &lt;&gt; 0 Then
        System.Abort WIRESYSTEMLib.eWAS_USER_ABORT ' abort
        Dim sErr : sErr = "System_AbortRequest handler: " &amp; Err.Source &amp; ": " &amp; Err.Description
        Logger.Error sErr
    End If

    If bWasSleeping Then Wake
    On Error Goto 0
End Sub

'
' AbortState
'       Returns the abort state of the current measurement
'
Public Function MmtAbortState
    MmtAbortState = WIRESYSTEMLib.eWAS_OK
    On Error Resume Next
    'MmtAbortState = Measurement.Result.Element("", "abortState")   'WXDREMOVE : TODO need to change appropriately
    MmtAbortState =  Measurement.WdfProperties("WiREData").item("abortState")
    Logger.Info "mmt abort state = " &amp; CStr(MmtAbortState) &amp; ": errNum = " &amp; CStr(Err.Number)
    On Error Goto 0
end function

Public Function SetMmtAbortState(newState)
    SetMmtAbortState = false
    On Error Resume Next
    Measurement.WdfProperties("WiREData").item("abortState") = newState
    If Err.number &lt;&gt; 0 then
        Measurement.WdfProperties("WiREData").Add "abortState", newState
    End If
    On Error Goto 0
    SetMmtAbortState = true
end function
'
' -------------------------------------------------------------------------
' Sleep for a while whilst permitting Abort to work
'
Private Sub SleepWithAbort(nDelay, nInterval)
    Dim nTime : nTime = 0
    g_bSleeping = True
    Do While g_bSleeping And nTime &lt; nDelay
        Dim nWaited: nWaited = Sleep2(nInterval)
        nTime = nTime + CLng(nWaited)
    Loop
End Sub

Private Sub SleepWithAbortMsg(nDelay, nInterval, sTemplate)
    Dim nTime : nTime = 0
    Dim nMsgChange : nMsgChange = 1000
    g_bSleeping = True
    Do While g_bSleeping And nTime &lt; nDelay
        Dim nWaited: nWaited = Sleep2(nInterval)
        nTime = nTime + CLng(nWaited)
        If nTime &gt; nMsgChange Then
            Activity FormatMessage(sTemplate, CLng(nTime / 1000), CLng(nDelay / 1000))
            nMsgChange = nMsgChange + 1000
        End If
    Loop
End Sub

'&lt;HACK&gt;
' -------------------------------------------------------------------------
' Replicate datasets to simulate RA scan result
'                                               'WXDREMOVE : can be removed not used anymore : check with Pat
'Private Function Replicate(oMemfile)
'    Dim nCount : nCount = oMemfile.NumberOfDataSets
'    LogMessage "Replicate: received " &amp; nCount &amp; " datasets."
'    If nCount &lt; 2 Then
'        Dim n: For n = nCount To 2
'            Dim sNew : sNew = "DataSet" &amp; CStr(n)
'            LogMessage "Replicate: add dataset " &amp; sNew
'            CloneDataSet oMemfile, "DataSet0", sNew
'        Next
'        LogMessage "Replicate: oMemfile now has " &amp; oMemfile.NumberOfDataSets &amp; " datasets."
'    End If
'    Set Replicate = oMemfile
'End Function

'' Clone a dataset from oSourceDataSet to oMemfile,sNewName
'Public Sub CloneDataSet(oMemfile, sSourceDataSet, sNewDataSet)
'    Dim oNew, oSource
'    ' Get the source dataset
'    Set oSource = oMemfile.Element("", sSourceDataSet)

'    ' Create the new destination dataset
'    oMemfile.CreateDataSet(sNewDataSet)
'    Set oNew = oMemfile.Element("", sNewDataSet)

'    ' Get the set of keys to use
'    Dim nIndex, oKeys, sKey
'    Set oKeys = CreateObject("Renishaw.WiRECollectionCom")
'    For nIndex = 1 To oSource.Count
'        oKeys.Add oSource.Key(nIndex)
'    Next

'    For Each sKey in oKeys
'        On Error Resume Next
'            If TypeName(oSource.Item(sKey)) = "IWiREDataListCom2" Then
'                Dim oDL, oNewDL
'                Set oDL = oSource.Item(sKey)
'                oMemfile.CreateDataList sNewDataSet, sKey, oDL.Count, True
'                Set oNewDL = oMemfile.Element(sNewDataSet, sKey)
'                oNewDL.VariantData(0, -1) = oDL.VariantData(0, -1)
'            Else
'                oNew.Add sKey, oSource.Item(sKey)
'            End If
'        On Error Goto 0
'    Next
'End Sub

'&lt;/HACK&gt;

' -------------------------------------------------------------------------
' On Scan complete, add the resulting data to the main memory file.
' Also notify the measurement listers that the data has changed.
'
Public Sub Scan_ScanComplete(oSpectrums)
        Measurement.WdfResultSpectrums = oSpectrums
        g_bMinimalScanComplete = True
        if (Acquisition.AcqMode = eCompleteSeries ) then
            Logger.Log "Measurement script firing Measurement.RaiseDataUpdate dutScanComplete, oSpectrums from the Scan_ScanComplete event."
            Measurement.RaiseDataUpdate dutScanComplete,oSpectrums
        End If
        On Error Resume Next
            
    If Err.Number &lt;&gt; 0 Then Logger.Error Err.Source &amp; ": " &amp; Err.Description
        
    Acquisition.ScanComplete
    If Err.Number &lt;&gt; 0 Then
        Dim sErr : sErr = "ScanComplete handler: " &amp; Err.Source &amp; ": " &amp; Err.Description
        Activity sErr : Logger.Error sErr
    End If
    On Error Goto 0
    Wake
End Sub

' -------------------------------------------------------------------------
' MapScanComplete event signifies that a new dataset has been
' added by a map scan
'
Public Sub Scan_MapScanComplete(oSpectrums)
    Measurement.WdfResultSpectrums = oSpectrums
    if (Acquisition.AcqMode &lt;&gt; eCompleteSeries ) then
        ' Shouldn't get here
        'Logger.Error "Map scan complete received, but shouldn't be doing one."
        Logger.Log "Measurement script firing Measurement.RaiseDataUpdate dutScanComplete, oSpectrums for an open series (ie open-ended series)"
        Measurement.RaiseDataUpdate dutScanComplete, oSpectrums
    else
        On Error Resume Next
        ' Should probably do our incremental saving here.
        Logger.Log "Measurement script firing Measurement.RaiseDataUpdate dutScanComplete, oSpectrums."
        Measurement.RaiseDataUpdate dutScanComplete, oSpectrums
        Logger.Log "  Measurement script finished firing Measurement.RaiseDataUpdate(dutScanComplete, oSpectrums). Err.Number = " &amp; CStr(Err.Number)
        If Err.Number &lt;&gt; 0 Then LogMessage "Scan_MapScanComplete: " &amp; "(" &amp; Err.Source &amp; ") " &amp; Err.Description
    end if
        
    ' Don't wake. The scan is not really complete
End Sub

' -------------------------------------------------------------------------
' On Scan update propagate the event to our listeners.
'
Public Sub Scan_DataUpdate(oSpectrums)
    g_nUpdates = g_nUpdates + 1
    On Error Resume Next
    Logger.Log "Measurement Scan_DataUpdate firing Measurement.RaiseDataUpdate dutScanUpdate, oSpectrums."
    Measurement.RaiseDataUpdate dutScanUpdate, oSpectrums
    If Err.Number &lt;&gt; 0 Then LogMessage "Scan_DataUpdate: " &amp; "(" &amp; Err.Source &amp; ") " &amp; Err.Description
End Sub

' -------------------------------------------------------------------------
' On Scan Error propagate the event to our listeners.
'
Public Sub Scan_ScanError(sErrorSource, sErrorDescription, nErroCode)
    On Error Resume Next
    Logger.Warn "Entered in Scan_ScanError."
    UpdateResultErrors vbObjectError+1, sErrorDescription, sErrorSource

    g_bMinimalScanComplete = True
    'In case of error declare that scan is completed with error logged into result wdf file or in diagnostic.
    Acquisition.ScanComplete
    If Err.Number &lt;&gt; 0 Then
        Dim sErr : sErr = "ScanComplete handler: " &amp; sErrorSource &amp; ": " &amp; sErrorDescription
        Activity sErr : Logger.Error sErr
    End If
    On Error Goto 0
    Wake
End Sub

Public Sub Scan_DataSaturated()
    Logger.Log "Data Saturated!"
    Acquisition.ModifyForSaturationProtection(Scan)
End Sub

' -------------------------------------------------------------------------
' FocusTrack event handler
Public Sub FocusTrack_FocusCompleted(bSuccess, dCentre, oMemFile)
    Acquisition.FocusTrackComplete bSuccess, dCentre, oMemFile
    Wake
End Sub


' -------------------------------------------------------------------------
' Calculate the time to complete this measurement. In Seconds.
'
Public Function TimeToComplete()
    If Acquisition Is Nothing Then
        Logger.Warn "TimeToComplete Created a new Acquisition instance! Check logic?"
        Set Acquisition = New CAcquisition
    End If
    Dim nTimeS
    nTimeS = (Scan.DurationEstimate * Acquisition.Count) _
            + ((Acquisition.Interval * (Acquisition.Count - 1)/1000.0))
    Logger.Log "Calculated measurement time to completion is " &amp; CStr(nTimeS) &amp; "s"
    TimeToComplete = nTimeS
End Function

' -------------------------------------------------------------------------
' Output activity messages to inform the user of our current activity.
Private Sub Activity(newVal)
    Dim s: s = newVal
    LogMessage CStr(s)
    On Error Resume Next 
    If IsObject(Acquisition) And Not(Acquisition Is Nothing) Then
        If Acquisition.HaltAfterAcc Then
            s = "Aborting after accumulation: " &amp; s
        ElseIf Acquisition.HaltAfterScan Then
            s = "Aborting after scan: " &amp; s
        End If
    end if
    If Err.Number &lt;&gt; 0 then Logger.Error Err.Description
    On Error Goto 0

    If IsObject(Scan) Then
        On Error Resume Next
        Scan.Activity = CStr(s)
    End If
End Sub

' -------------------------------------------------------------------------
' Construct a unique filename by affixing a digit to the end of the 
' basename.
'
Public Function UniqueFilename(sRootName)
    Dim nIncrement : nIncrement = 1 'bug 1105 - auto-increment to begin at 1.
    Dim sTempName  : sTempName = sRootName
    Dim sBaseName  : sBaseName = GetBaseName(sRootName)
    sBaseName = sBaseName &amp; "-"
    Dim sExtension : sExtension = GetExtension(sRootName)
    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
    Do While oFSO.FileExists(sTempName)
        sTempName = sBaseName &amp; CStr(nIncrement) &amp; "." &amp; sExtension      'WXDREMOVE : WDFADD : PVK need to add ".wdf" as extension for incremental Save
        nIncrement = nIncrement + 1
    Loop    
    UniqueFilename = sTempName
End Function

Public Function getTempWdfFilename()
'    Dim sTempName  : sTempName = GetTemporaryFile("wdf")           'WXDREMOVE : WDFADD : Check and remove
'    Dim sBaseName  : sBaseName = GetBaseName(sTempName)
'    Dim sExtension : sExtension = GetExtension(sTempName)
'    
'    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
'    if oFSO.FileExists(sTempName) then
'        sTempName = sBaseName &amp; "." &amp; sExtension  
'        Dim sTempWdfFile : sTempWdfFile = sBaseName &amp; "." &amp; "wdf"
'        oFSO.MoveFile  sTempName,sTempWdfFile    
'    End if
'    getTempWdfFilename = sTempWdfFile
    Dim oFSO       : Set oFSO = CreateObject("Scripting.FileSystemObject")
    Dim sTempName  : sTempName = oFSO.GetTempName
    Dim sBaseName  : sBaseName = GetBaseName(sTempName)
    Dim stempFolder: stempFolder = oFSO.GetSpecialFolder(2)    
    getTempWdfFilename = stempFolder &amp; "\" &amp; sBaseName &amp; "." &amp; "wdf"
End Function


Private Function GetExtension(sName)
    Dim aSplit : aSplit = Split(sName, ".")
    GetExtension = aSplit(UBound(aSplit))
End  Function

Private Function GetBaseName(sName)
    Dim sExt : sExt = GetExtension(sName)
    GetBaseName = Left(sName, Len(sName) - Len(sExt) - 1)
End  Function

Private Function SequencedFilename(sRootName, nNumber)
    SequencedFilename = GetBaseName(sRootName) _
        &amp; "-" &amp; CStr(nNumber) &amp; "." &amp; GetExtension(sRootName)
End Function

' -------------------------------------------------------------------------
' Dump an object to an XML file for examination.
'
Public Sub DumpToXML(oThing, sFilename)
    Dim doc, node, bag
    Set doc = CreateObject("MSXML.DOMDocument")
    Set node = doc.createElement("Persisted")
    Set node = doc.appendChild(node)
    Set bag = CreateObject("Renishaw.PropertyBagOnXML")
    bag.save oThing, node
    doc.save sFilename
End Sub

' -------------------------------------------------------------------------
' Pre- and post- error event handlers
'
Public Sub PlugIn_HasError
    System.Abort WiRESystemLib.eWAS_USER_ABORT
End Sub

Private Sub AbortRunningPlugIns(bForce)
    g_pluginPreMmtManager.Abort bForce
    g_pluginInitMmtManager.Abort bForce
    g_pluginPostMmtManager.Abort bForce
End Sub

''' -------------------------------------------------------------------------
'Include "wirelib:Logger.vbs"
''' -------------------------------------------------------------------------
' Logger.vbs - Written by Pat Thoyts, Copyright (C) 2002 Renishaw plc
'
' Provide status logging through the WiRE2 Diagnostic display object.
'
' TypeLib: WIREDIAGNOSTICHELPERLib 1.0 = {69C18F55-7026-41FB-97E5-AE2FF9CBA9DE}
'

Import "Renishaw.WiREDiagnosticHelper"
      
Class CLogger
    Private m_DiagnosticServer
    Private m_sLogName
    Private m_eLogType

    Private Sub Class_Initialize
        Set m_DiagnosticServer = CreateObject("Renishaw.WiREDiagnosticHelper")
        m_sLogName = "Measurement"
        m_eLogType = eWIRE_MEASUREMENT
    End Sub
    
    Public Property Get Name() : Name = m_sLogName : End Property
    Public Property Let Name(newVal) : m_sLogName = CStr(newVal) : End Property

    Public Property Get Application() : Application = m_eLogType : End Property
    Public Property Let Application(newVal) : m_eLogType = newVal : End Property

    Public Sub Error(Message)
        m_DiagnosticServer.LogWiRE2Event eAPPLICATION_CRITICAL, _
            m_eLogType, m_sLogName, Message
    End Sub

    Public Sub Warn(Message)
        m_DiagnosticServer.LogWiRE2Event eAPPLICATION_NONCRITICAL, _
            m_eLogType, m_sLogName, Message
    End Sub

    Public Sub Log(Message)
        m_DiagnosticServer.LogWiRE2Event eAPPLICATION_FUNCTION, _
            m_eLogType, m_sLogName, Message
    End Sub

    Public Sub Debug(Message)
        m_DiagnosticServer.LogWiRE2Event eAPPLICATION_INFORMATION, _
            m_eLogType, m_sLogName, Message
    End Sub
End Class

''' -------------------------------------------------------------------------
'Include "wirelib:AutoMultiSequenceOperation.vbs"
''' -------------------------------------------------------------------------
' AutoMultiSequenceOperation.vbs - Written by Pat Thoyts, Copyright (C) 2002 Renishaw plc
'
' Provide instrument lamp management
'
' Require "wirelib:Logger.vbs"

Class CAutoMultiSequenceOperation
    Private m_oSystem   ' the system object
    Private m_oLogger   ' our logger object
    Private m_sName     ' Our multi sequence operation name
    Private m_bStarted  ' True if the operation is started
    Private m_bDebug    ' Set this to True to see Log messages

    Private Sub Class_Initialize()
        Set m_oSystem = Nothing
        Set m_oLogger = New CLogger
        m_sName = "AutoMultiSequenceOperation"
        m_bStarted = False
        m_bDebug = False
    End Sub

    Private Sub Class_Terminate
        If m_bDebug Then Logger.Log "CAutoMultiSequenceOperation Class_Terminate"
        Halt
    End Sub

    Public Sub Init(oSystem)
        Set Me.System = oSystem
    End Sub

    Public Property Get System() : Set System = m_oSystem : End Property
    Public Property Set System(oSystem) : Set m_oSystem = oSystem : End Property

    Public Property Get Name() : Name = m_sName :  End Property
    Public Property Let Name(sName) : m_sName = CStr(sName) : End Property

    Public Property Get Debug() : Debug = m_bDebug :  End Property
    Public Property Let Debug(bDebug) : m_bDebug = CBool(bDebug) : End Property

    Public Sub Start()
        If IsObject(m_oSystem ) And Not(m_oSystem Is Nothing) Then
            On Error Resume Next
            m_oSystem.MultiSequenceOperation 0, m_sName
            If Err.Number = 0 Then
                m_bStarted = True
                If m_bDebug Then m_oLogger.Log "CAutoMultiSequenceOperation Start(): Started " &amp; m_sName
            Else
                If m_bDebug Then m_oLogger.Error "CAutoMultiSequenceOperation Start(): " &amp; Err.Description
            End If
        Else
            Raise "Start", "You must assign the System property to start a multi sequence operation."
        End If
    End Sub

    Public Sub Halt()
        If IsObject(m_oSystem ) And Not(m_oSystem Is Nothing) Then
            m_oSystem.MultiSequenceOperation 1, m_sName
            m_bStarted = False
        Else
            Raise "Halt", "You must assign the System property to stop a multi sequence operation."
        End If
    End Sub

    Private Sub Raise(sLocation, sMessage)
        m_oLogger.Error "CAutoMultiSequenceOperation Error: " &amp; sMessage
        Err.Raise vbObjectError + 1, "CAutoMultiSequenceOperation_" &amp; sLocation, sMessage
    End Sub

End Class

''' -------------------------------------------------------------------------
'Include "wirelib:CameraWrapper.vbs"
''' -------------------------------------------------------------------------
' CameraWrapper.vbs - Written by Pat Thoyts, Copyright (C) 2002 Renishaw plc
'
' Provide a wrapper around the WiRECameraCom object and in particular a method
' to report information about the current state of the camera - ReportCameraStatus
'
' Version: 2.0.9.0

Class CCameraWrapper
    Private m_oCamera
    Private m_nInitialDataCount
    Private m_nLastDataCount
    
    Private Sub Class_Initialize()
        Set m_oCamera = Nothing
    End Sub

    ' Initialize the instance from a System object
    Public Sub Init(oSystem)
        Set m_oCamera = oSystem.USBCamera
        m_nInitialDataCount = GetLongAt(Me.Status, 12)
        m_nLastDataCount = m_nInitialDataCount
    End Sub

    ' Initialize from a Camera object
    Public Property Set Camera(newVal) : Set m_oCamera = newVal : End Property
    Public Property Get Camera() : Set Camera = m_oCamera : End Property
    
    Public Property Get Initialized()
        Initialized = IsObject(m_oCamera) And Not(m_oCamera Is Nothing)
    End Property
    
    Public Function CreateCommand(nID)
        CreateCommand = Array(nID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    End Function

    ' Dump the contents of a USB command array for debugging
    Public Function DumpCommand(aCommand)
        Dim n, s
        For n = 0 To 15
            s = s &amp; " " &amp; CStr(aCommand(n))
        Next
        DumpCommand = s
    End Function

    Public Function TraceBuffer()
        Dim aCmd : aCmd = CreateCommand(99)
        aCmd(1) = CByte(255)
        aCmd(2) = 0
        
        Dim aRes, nCount, nIndex, aTrace, nByte
        aRes = m_oCamera.Exec(aCmd)
        If aRes(0) &lt;&gt; 0 Then
            ReDim aTrace(0)
        Else
            nCount = aRes(1) + (aRes(2) * &amp;h100)
    
            ReDim aTrace(nCount)
            For nIndex = 0 To nCount Step 13
                aCmd(2) = nIndex And 255
                aCmd(3) = nIndex / 256
                aRes = m_oCamera.Exec(aCmd)
                For nByte = 0 To 12
                    If nIndex + nByte &lt; nCount Then _
                        aTrace(nIndex + nByte) = aRes(nByte+3)
                Next
            Next
        End If
        TraceBuffer = aTrace
    End Function

    Private Function GetLongAt(aArray, nStartPos) 'intel byte order
        GetLongAt = aArray(nStartPos) + (aArray(nStartPos+1) * &amp;H100) _
            + ((aArray(nStartPos+2) + (aArray(nStartPos+3) * &amp;H100)) * &amp;H10000)
    End Function

    Public Property Get Status()
        If Me.Initialized Then 
            Status = m_oCamera.Exec(CreateCommand(19)) ' SEQ_STATUS2
        Else
            Err.Raise vbObjectError+1, "Diagnostics", "CameraWrapper has not been initialized with a camera instance."
        End If
    End Property

    Public Sub SequenceReset()
        If Me.Initialized Then 
            m_oCamera.Send CreateCommand(2) ' SEQ_RESET
        Else
            Err.Raise vbObjectError+1, "Diagnostics", "CameraWrapper has not been initialized with a camera instance."
        End If
    End Sub

    Public Property Get Diagnostics(nSubCommand)
        If Me.Initialized Then
            Dim aCmd : aCmd = CreateCommand(99) ' DIAGNOSTICS
            aCmd(1) = CByte(nSubCommand)
            Diagnostics = m_oCamera.Exec(aCmd)
        Else
            Err.Raise vbObjectError+1, "Diagnostics", "CameraWrapper has not been initialized with a camera instance."
        End If
    End Property

    Public Function ReportCameraStatus()
        Dim aStatus: aStatus = Me.Status
        Dim nCount : nCount = GetLongAt(aStatus, 12)
        Dim aDiags : aDiags  = Me.Diagnostics(6)
        Dim nCCDWords : nCCDWords = GetLongAt(aDiags, 3)
        Dim nEP2BufCount : nEP2BufCount = GetLongAt(aDiags, 7)
        Dim s

        s = s &amp; " ErrCode: " &amp; aStatus(0)
        s = s &amp; " Running: " &amp; aStatus(1)
        s = s &amp; " CommandNo: " &amp; aStatus(2)
        s = s &amp; " FinalCmd: " &amp; aStatus(8)
        s = s &amp; " CommandID: " &amp; aStatus(3)
        s = s &amp; " CCD Words: " &amp; nCCDWords
        s = s &amp; " EP2Buffer: " &amp; nEP2BufCount
        s = s &amp; " DataCount: " &amp; nCount
        s = s &amp; " DiffCount: " &amp; nCount - m_nLastDataCount

        m_nLastDataCount = nCount
        ReportCameraStatus = s
    End Function
    
End Class

''' -------------------------------------------------------------------------
'Include "wirelib:XYZStage.vbs"
''' -------------------------------------------------------------------------
' XYZStage.vbs - Copyright (c) 2002 Renishaw plc
'
' Wrapper for the XYZ stage object
'
' Requires "wirelib:Logger.vbs"

' TypeLib: WIREXYZLib 1.0    = {dae0ff43-c76e-11d4-8945-00003c508b6f}

Import "{dae0ff43-c76e-11d4-8945-00003c508b6f}"
Import "Renishaw.WiRESystemCom"
      

' -------------------------------------------------------------------------
' Include "wirelib:TemperatureStage.vbs"
' -------------------------------------------------------------------------
' TemperatureStage.vbs - Copyright (C) 2002-2009 Renishaw plc
'
' Set Linkam hot-cold stage temperature via the RS232 Port
' The TMS93/94 operates in degrees C and degrees C/min. WiRE operates in degrees absolute and
' so we'll need to convert in here.
'
Const s_Version_TemperatureStage = "3.2.2.3"
Const AbsoluteZero = 273.15

Class CEmulationTemperatureStage
    ' This class takes values from CAcquisition which are in Kelvin and returns
    ' values in Kelvin. This is because CEmulationTemperatureStage must return
    ' the same unit types as CTemperatureStage which communicates in Kelvin. 
    ' This class also communicates with the TMS Emulator COM object which gives
    ' and takes values in Celsius as it also has to communicate with the ATC
    ' which only communicates in celsius.
    Private m_oTMSEmulator
    Private m_nRamp
    Private m_bAbort

    Private Sub Class_Initialize()
        set m_oTMSEmulator = nothing
    End Sub

    ' create the tms emulator in the system object so that it can be shared with the
    ' AdvancedTemperatureControl application.
    Public Sub Init(oSystem)
        Dim oProps: set oProps = oSystem.HostedObject(eSHO_PROPERTIES)
        if oProps.Exists("TMSEmulator") = false then
            dim oTmp: Set oTmp = oProps.Create("TMSEmulator", "Renishaw.TMSEmulatorCom")
        end if
        if oProps.Exists("TMSEmulator") = false then
            MsgBox "Failed to create Renishaw.TMSEmulatorCom"
        End if
        set m_oTMSEmulator = oProps.Item("TMSEmulator")
        'm_oTMSEmulator.ShowUI 0
    End Sub

    Public Property Get Ramp() : Ramp = m_nRamp : End Property
    Public Property Let Ramp(newVal) : m_nRamp = CDbl(newVal) : End Property

    Public Property Get Abort() : Abort = m_bAbort : End Property
    Public Property Let Abort(newVal) : m_bAbort = CBool(newVal) : End Property

    ' The input parameter is in Kelvin
    Public Sub SetTemperatureAsync(newVal_inKevlin)
        'Ensure that the target value is converted to ºC
        Dim tempCelsius : tempCelsius = newVal_inKevlin - AbsoluteZero
        m_oTMSEmulator.SetTemperatureAsync tempCelsius
    End Sub

    ' The input parameter is in Kelvin
    Public Property Let Temperature(newVal_inKevlin)
        Dim tempCelsius : tempCelsius = newVal_inKevlin - AbsoluteZero
        
        m_oTMSEmulator.SetTemperatureAsync tempCelsius

        'Wait for temperature holding
        dim dTemp: dTemp = m_oTMSEmulator.Temperature

        'Timeout after 1000secs?
        Dim iCount : iCount = 0
        m_bAbort = False
        Do While Not(m_bAbort) And (abs(dTemp-tempCelsius) &gt; 0.1) And iCount &lt; 100000
            Sleep 10
            dTemp = m_oTMSEmulator.Temperature
            iCount = iCount + 1
        Loop

        'Set to holding
        If m_bAbort Then
            m_oTMSEmulator.Temperature = tempCelsius
        End If

    End Property

    ' Returns Kelvin
    Public Property Get Temperature()
        ' m_oTMSEmulator.Temperature is in Celsius
        Temperature = m_oTMSEmulator.Temperature + AbsoluteZero
    End Property

    ' Returns Kelvin
    Public Function ReadQuietly()
        ReadQuietly = Temperature()
    End Function

    Public Sub Hold ()
        m_oTMSEmulator.Hold
    End Sub

End Class


Class CTemperatureStage
    Private m_sType
    Private m_bUseSerialComms
    Private m_bUseLinkamCommsMethod
    Private m_oComm
    Private m_nComPort
    Private m_sComSettings
    Private m_nComHandshaking
    Private m_nRamp
    Private m_nInterval
    Private m_bAbort
    Private m_bLog
    Private m_bTestMode
    Private m_TestTemp
    
    Private Sub Class_Initialize()
        m_bUseSerialComms = true          ' Shows whether to use serial comms or USB connection
        m_bUseLinkamCommsMethod = false   ' Shows whether to use LinkamCommsLibrary or direct serial port communications to talk to the controller
        m_sType = "TMS94"                 ' one of TMS92, TMS93, TMS94, T95
        m_nComPort = 1                    ' default is COM1
        m_sComSettings = "19200,N,8,1"    ' default params (default for TMS93/94
        m_nComHandshaking = 2             ' 0: none, 1: xonxoff, 2: rtscts
        m_nRamp = 5
        m_nInterval = 10
        m_bLog = True
        m_bTestMode = false

    End Sub
    
    Private sub LogMessage2(s)
        LogMessage s
        Logger.Log s
    End Sub

    Private Sub Class_Terminate()
        If PortOpen Then
            On Error Resume Next
            ' Make sure that the stage is holding at the end of the measurement.
            Hold
            ' Do not disconnect the stage. There is no benefit in repeatedly opening and closing the connection
            ' and another application using the copy from hosted objects may not expect it to disconnect.
        End If
    End Sub
    
    Public Sub Init(oSystem)
        ' Try and get copy of WiRELinkamBridgeLayerCom object from the hosted objects collection.
        ' If it doesnt already exist, an object will be created and the new object will be returned.
        Set m_oComm = oSystem.HostedObject(eSHO_LINKAM_BRIDGE)
        ' Enable or disable logging
        m_oComm.LoggingEnabled = m_bLog
        
        Dim oProps : Set oProps = oSystem.HostedObject(eSHO_PROPERTIES)
        On Error Resume Next
            Me.TMSType = CStr(oProps.Item("TemperatureStageType"))
            
            ' If property does not exist or is true, serial comms will be used. Otherwise, it'll connect via USB.
            m_bUseSerialComms = CBool(oProps.Item("TemperatureStageUseSerialComms"))

            ' If the property does not exist or is false, then old style hex-based serial comms will be used. Otherwise, the LinkamCommsLibrary dll will be used.
            m_bUseLinkamCommsMethod = CBool(oProps.Item("TemperatureStageUseLinkamLibraryComms"))

            Me.Port = CStr(oProps.Item("TemperatureStagePort"))
            Me.Settings = CStr(oProps.Item("TemperatureStageSettings"))
            Me.Handshaking = CLng(oProps.Item("TemperatureStageHandshaking"))

            ' As soon as the bridge object and measurement properties are retrieved from the hosted objects, connect to the 
            ' bridge, if it is not connected already.
            If Not PortOpen Then
                PortOpen = true
                If m_bLog Then 
                    If m_bUseSerialComms Then

                        Dim sCommsMethod
                        If UsingLinkamCommsLibrary Then
                            sCommsMethod = "LinkamCommsLibrary"
                        Else
                            sCommsMethod = "String based commands"
                        End If

                        LogMessage2 "Initialized " &amp; Me.TMSType &amp; " on COM" &amp; Me.Port &amp; ". Communication method: " &amp; sCommMethod
                    Else
                        LogMessage2 "Initialized " &amp; Me.TMSType &amp; " on USB. Communication method: LinkamCommsLibrary"
                    End If
                End If
            End If
        On Error Goto 0
        If Err.Number &lt;&gt; 0 Then LogMessage2 "TMS Error: " &amp; Err.Message

    End Sub

    Public Property Get Port() : Port = m_nComPort : End Property
    Public Property Let Port(newVal) : m_nComPort = CLng(newVal) : End Property

    Public Property Get Settings() : Settings = m_sComSettings : End Property
    Public Property Let Settings(newVal) : m_sComSettings = CStr(newVal) : End Property

    Public Property Get Handshaking() : Handshaking = m_nComHandshaking : End Property
    Public Property Let Handshaking(newVal) : m_nComHandshaking = CLng(newVal) : End Property

    Public Property Get Ramp() : Ramp = m_nRamp : End Property
    Public Property Let Ramp(newVal) : m_nRamp = CDbl(newVal) : End Property

    Public Property Get Object() : Set Object = m_oComm : End Property

    Public Property Get TMSType() : TMSType = m_sType : End Property
    Public Property Let TMSType(newVal)
        m_sType = CStr(newVal)
        If m_sType = "TMS95" Then m_sType = "T95"      ' it is called T95 now
    End Property

    Public Property Get UsingSerialComms() : UsingSerialComms = m_bUseSerialComms : End Property

    Public Property Get UsingLinkamCommsLibrary() : UsingLinkamCommsLibrary = m_bUseLinkamCommsMethod : End Property

    Public Property Get Abort()
        Abort = m_bAbort
    End Property
    Public Property Let Abort(newVal)
        m_bAbort = CBool(newVal)
    End Property

    Public Sub Reset()
        Sleep 100
        m_oComm.StopEverything
    End Sub

    ' Set the TMS target temperature and begin ramping.
    Public Sub SetTemperatureAsync(newVal)
        Dim nTarget
        ' Convert new value from Kelvin to degrees celsius.
        nTarget = newVal - AbsoluteZero

        if (m_bTestMode) then m_TestTemp = newVal

        'Set step 1: ramp, limit, and hold interval
        m_oComm.RampRate = m_nRamp
        m_oComm.TargetTemperature = nTarget
        ' This command appears to be required for pre TMS93 stages
        If m_sType = "TMS92" Then 
            m_oComm.HoldInterval = Clng(m_nInterval)
        End If

        'Start
        m_oComm.StartRamping
    End Sub

    Public Sub Hold ()
        m_oComm.StartHolding
    End Sub

    ' Set the temperature of the TMS93 Stage
    ' Parameters should be in K
    Public Property Let Temperature(newVal)

        ' Command hardware to change its temperature
        SetTemperatureAsync newVal

        'Wait for temperature to ramp up/down and start holding
        'Timeout after 1000secs?
        Dim iCount : iCount = 0
        m_bAbort = False
        If (Not m_bTestMode) then
            
            Dim iCurrentAction : iCurrentAction = 1 '0=error, 1=idle , 2=heating, 3=cooling, 4=holding
            Dim iErrorCode : iErrorCode = 0
            Dim sErrorMessage
            Dim fCurrentTemperature : fCurrentTemperature = 0

            Do While Not(m_bAbort) And (iCurrentAction = 2 Or iCurrentAction = 3) And iCount &lt; 100000
                Sleep 10
                On Error Resume Next
                m_oComm.GetTMSStatus iCurrentAction, iErrorCode, sErrorMessage, fCurrentTemperature
                If Err.Number &lt;&gt; 0 Then Logger.Error Err.Description &amp; " : " &amp; Err.Source
                On Error Goto 0
                iCount = iCount + 1
            Loop
        End If

        'Set to holding
        If m_bAbort Then
            Reset
        Else
            Hold
        End If

    End Property

    Public Property Get Temperature()
        Dim nCount, nC, nK
        nK = -1 : nC = -1
        If (not m_bTestMode) then
            For nCount = 0 To 3
                ' Try and get temperature from from device. If it succeeds without error, exit the loop.
                ' If not, try again (max 3 times).
                On Error Resume Next
                nC = m_oComm.CurrentTemperature
                If Err.Number &lt;&gt; 0 Then 
                    Logger.Error Err.Description &amp; " : " &amp; Err.Source
                Else
                    On Error Goto 0
                    nK = nC + AbsoluteZero
                    Temperature = nK
                    Exit For
                End If
                LogMessage2 "Get Temperature sleep"
                Sleep 200
            Next
        Else
            nK = m_TestTemp
            Temperature = m_TestTemp
        End If

        If nK &lt; 0 Then
            Err.Raise vbObjectError + 1, "CTemperatureStage_Temperature", _
                "Failed to read reply string from temperature stage."    
        End If
    End Property

    Public Function ReadQuietly()
        On Error Resume Next
        ReadQuietly = 0
        dim timeout: timeout = 1000
        dim time_used: time_used = 0
        dim bTimeout: bTimeout = false

        Do While Not(m_oComm.IsConnected And Not(bTimeout))
            Err.Clear
            Me.PortOpen = True
            If Err.Number &lt;&gt; 0 Then
                Sleep 250
                time_used = time_used + 250
                if time_used &lt; timeout then 
                    LogMessage2 "Retrying port open..."
                else
                    bTimeout = true
                end if 
            End If
        Loop
    if Not(bTimeout) then  
        ReadQuietly = Me.Temperature
    end if
    End Function

    Public Property Let PortOpen(bOpen)
        If bOpen then
            ' Connect up the object with the chosen connection method and appropriate connection function and com port settings, if using serial comms.
            ' Connection also includes setting the pump control mode to automatic for ALL controller models.
            If m_bUseSerialComms Then
                ' For serial connections, there are different connection functions depending on which communication method is being used.
                If m_bUseLinkamCommsMethod Then
                m_oComm.ConnectViaSerialComms m_nComPort
                Else
                m_oComm.ConnectDirectToSerialPort m_sType, m_nComPort, m_sComSettings, m_nComHandshaking
                End If
            Else
                m_oComm.ConnectViaUsb
            End If

        Else 
            ' Disconnect the device. Same function used for both connection types.
            m_oComm.Disconnect

        End If
    End Property

    Public Property Get PortOpen()
        PortOpen = False
        If IsObject(m_oComm) And Not(m_oComm Is Nothing) Then
            PortOpen = m_oComm.IsConnected
        End If
    End Property

End Class

' -------------------------------------------------------------------------
' Include "wirelib:ExplodeLineFocus.vbs"
' -------------------------------------------------------------------------
' ExplodeLineFocus.vbs - Copyright (C) 2002 Renishaw plc

' Modified to explode inplace for each collected dataset.

' Get the Linefocus stepsize value. (Binning independant).
Function GetLinefocusStepSize
    ' The Wizard puts this in to the properties for us.
    GetLinefocusStepSize=0
    On Error Resume Next
        GetLinefocusStepSize = Measurement.Properties("yStepSize")
        If Err.Number = 0 Then Exit Function
    On Error Goto 0

    ' We can also calulate it locally if required.
    Logger.Warn "Calculating Linefocus step size locally."
    Dim oCCD, oCCDArea
    Set oCCD = System.ICCD
    oCCD.SelectCCDFromKey InstrumentState.AreaKey
    Set oCCDArea = oCCD.ICurrentArea

    Dim dMIF, dPixelSizeMM, dObjective, dStepSize
    On Error Resume Next
        ' MicroscopeImageFactorForAreakey might not be populated so can't rely on this always returning S_OK
        dMIF = System.MicroscopeImageFactorForAreakey(InstrumentState.AreaKey.ID)
        If Err.Number = 0 Then Exit Function
    On Error Goto 0
    dPixelSizeMM = oCCD.YPixelSizeMillimetres
    dObjective = GetObjective()
    dStepSize = (3.0 * dMIF * dPixelSizeMM) / dObjective
    GetLinefocusStepSize = dStepSize
End Function

' Get the current objective value from the motor.
Function GetObjective
    on error resume next
    Dim oObjective
    Set oObjective = System.HostedObject(eSHO_OBJECTIVE) ' current objective
    if err.number &lt;&gt; 0 then
        Logger.Error "No current objective! Forcing to 50"
        GetObjective = 50    ' safe default
    else 
        GetObjective = oObjective.Magnification
    end if
    On Error Goto 0
End Function

' Calculate the Y center pixel from the currently selected area key.
Function CalculateYCenterPixel()
    Dim oCCDArea, nTop, nBottom
    Set oCCDArea = System.ICCD.ICurrentArea
    nTop = oCCDArea.AreaTop
    nBottom = oCCDArea.AreaBottom
    If nTop &gt; nBottom Then 
        nTop = nBottom
        nBottom = oCCDArea.Top
    End If
    CalculateYCenterPixel = nTop + ((nBottom - nTop) / 2)
End Function

' -------------------------------------------------------------------------
' Image Capture
'
' Once initialized, usage is GrabImage(1), GrabImage(2),
' SaveImages(oMemFile), UpdateDataset(oMemfile, sDataset) for 1 or more
' datasets then Reset() to forget the image paths and drop the collected
' images. We _always_ call all the above and the object will determine
' from measurement properties which images are actually captured and
' will update the datasets appropriately.
'
' Set imageCapture       to 0 for none, 1 for before, 2 for after or 3 for both
'     imageCapturePause  to the number of millisecs to wait for the image to
'                        settle down -- at least 1.5s is desirable.
'
Class CImageCapture
    Private m_eCaptureMode  ' none = 0, pre = 1, post = 2, both= 3
    Private m_nCapturePause ' millisecs to wait for image to settle.
    Private m_bIllumLampOn  ' whether or not to have the lamp on for the image capture.
    Private m_nLampBrightness  ' The illumination lamp intensity for the image capture.
    Private m_oPreImage     ' internal storage for the pre image object
    Private m_oPostImage    ' internal storage for the post image object
    Private m_sPrePath      ' path of the pre image in the memory file
    Private m_sPostPath     ' path of the post image in the memory file
    Private m_nUID          ' uid for image paths.
    Private m_bHavePodule   ' do we have a podule?
    Private m_bNotFirst     ' true if we have collected an image
    Private m_oInstrumentState
    Private m_oInstrument

    Private Sub Class_Initialize()
        m_eCaptureMode = 0
        m_nCapturePause = 1500
        m_nUID = 0
        m_bNotFirst = False
        Set m_oInstrumentState = Nothing
        Set m_oInstrument = Nothing

        Dim oPodule: Set oPodule = System.HostedObject(eSHO_PODULE)
        Dim lampMaxVal: lampMaxVal = 100    ' default to 100 as an arbitrary value; we'll read it from the podule below.
        Dim lampPercent: lampPercent = 50   ' arbitrary value in case we can't read it.
        
        m_bHavePodule = CBool(System.SystemType And eWSY_PODULE)
        m_bIllumLampOn = True   ' default to white light illumination ON.
        m_nLampBrightness = 75  ' arbitrary value

        On Error Resume Next
            m_eCaptureMode = CLng(Measurement.Properties("imageCapture"))
            m_nCapturePause = CLng(Measurement.Properties("imageCapturePause"))
            m_bIllumLampOn = CBool(Measurement.Properties("illuminationLampOn"))

            ' read the lamp brightness as a percentage and convert it to a real value 
            lampMaxVal = oPodule.LampMaxIntensity(eWHITE_ILLUMINATION)  ' the max illumination lamp value.
            lampPercent = CLng(Measurement.Properties("illuminationLampBrightnessPercent"))
            m_nLampBrightness = lampMaxVal * (lampPercent / 100.0)
            Logger.Debug "Lamp brightness " &amp; lampPercent &amp; "% converted using maxLampBrightness " &amp; lampMaxVal &amp; " to " &amp; m_nLampBrightness &amp; "."
        On Error Goto 0
        If m_eCaptureMode &gt; 3 Then
            Logger.Error "Illegal image capture mode """ &amp; m_eCaptureMode &amp; """. Set to 0."
            m_eCaptureMode = 0
        End If
        ' If capturing, check that the system supports video.
        If m_eCaptureMode &gt; 0 _
          And (System.SystemType And WIRESYSTEMLib.eWSY_VIDEO) &lt;&gt; WIRESYSTEMLib.eWSY_VIDEO Then
            Logger.Error "Image capture requested but video is unavailable"
        Else
            Logger.Debug "Image capture set to """ &amp; m_eCaptureMode &amp; """" _
              &amp; ". Image settling delay is " &amp; m_nCapturePause/1000.0 &amp; "s"
        End If
        Me.Reset
    End Sub
    
    public property Get IlluminationLampOn()
        IlluminationLampOn = m_bIllumLampOn
    End property

    public property Get IlluminationLampBrightness()
        IlluminationLampBrightness = m_nLampBrightness
    End property

    Public Property Let CaptureMode (newVal)
        If newVal &gt; 3 Then
    Logger.Error "Illegal image capture mode """ &amp; m_eCaptureMode &amp; """. Set to 0."
            m_eCaptureMode = 0
        End If
        ' If capturing, check that the system supports video.
        If newVal &gt; 0 _
          And (System.SystemType And WIRESYSTEMLib.eWSY_VIDEO) &lt;&gt; WIRESYSTEMLib.eWSY_VIDEO Then
            Logger.Error "Image capture requested but video is unavailable"
        Else
            Logger.Debug "Image capture set to """ &amp; newVal &amp; """" _
              &amp; ". Image settling delay is " &amp; m_nCapturePause/1000.0 &amp; "s"
        End If
        m_eCaptureMode = newVal
    End Property
    
    Public Property Get CaptureMode()
        CaptureMode = m_eCaptureMode
    End Property
    
    Public Sub GrabImage(eMode, bSettle)
        If eMode And m_eCaptureMode Then
            Dim s : If eMode = 1 Then s = "pre-scan" Else s = "post-scan"
            Logger.Debug "Capturing " &amp; s &amp; " image."

            If Not m_bHavePodule Then
                Dim bSkip : bSkip = m_eCaptureMode = 3 And eMode = 1 And m_bNotFirst
                If Not bSkip Then
                    MsgBox FormatMessage(g_sImageCollectMessage), vbOKOnly + vbQuestion + vbSystemModal, FormatMessage(g_sImageCollectTitle)
                End If
                bSettle = False
            End If
            
            On Error Resume Next
            GrabImageInternal eMode, bSettle
            If Err.Number &lt;&gt; 0 Then
                Logger.Error "Image capture error: " &amp; Err.Description &amp; " (" &amp; Err.Source &amp; ")"
            End If

            If Not m_bHavePodule Then
                ' Can skip if we are collecting both and this is the post image
                If Not(m_eCaptureMode = 3 And eMode = 2) Then
                    MsgBox FormatMessage(g_sDataCollectMessage), vbOKOnly + vbQuestion + vbSystemModal, FormatMessage(g_sDataCollectTitle)
                End If
            End If
            
            m_bNotFirst = True
        ElseIf m_eCaptureMode = 2 And eMode = 1 And Not(m_bNotFirst) Then
            ' For collecting after images, we still need to show the data warning on basis the first time round.
            If Not m_bHavePodule Then
                MsgBox FormatMessage(g_sDataCollectMessage), vbOKOnly + vbQuestion + vbSystemModal, FormatMessage(g_sDataCollectTitle)
            End If
        End If
    End Sub
    
    Private Sub GrabImageInternal(eMode, bSettle)
        SwitchToWhitelight

        On Error Resume Next
            System.VideoUseMode = eUSERVIDEO
            If Err.Number &lt;&gt; 0 Then
                Logger.Error "Caught error from System.VideoUseMode: " &amp; Err.Description
            End If
        On Error Goto 0

        On Error Resume Next
            System.UpdateVideoXYZPos
            Logger.Debug "System.UpdateVideoXYZPos called: Stage position:X= " &amp; System.xyz_StageXPosition &amp; "Y= " &amp; System.xyz_StageYPosition &amp; "Z= " &amp; System.xyz_StageZPosition
            If Err.Number &lt;&gt; 0 Then
                Logger.Error "Caught error from System.UpdateVideoXYZPos: " &amp; Err.Description
            End If
        On Error Goto 0

        Dim oVideo: Set oVideo = System.VideoViewer
        If Not(oVideo.IsDeviceInitialised) Then oVideo.InitialiseDevice 0
        If Not(oVideo.IsVideoPreviewing) Then oVideo.StartVideoPreview

        If bSettle Then
            SleepWithAbortMsg m_nCapturePause, 200, "Pausing for light balance to settle. %1s of %2s completed"
        End If

        If eMode = 1 Then
            Set m_oPreImage = oVideo.SaveImageToObject(0)
            Logger.Debug "Captured pre-scan video image."
        Else
            Set m_oPostImage = oVideo.SaveImageToObject(0)
            Logger.Debug "Captured post-scan video image."
        End If

        ' if we are collecting the post image, we should re-apply the Raman path 
        '   unless we are going to collect a pre image at the next point.
        if eMode = 2 then               ' we are in post-image grab
            if m_eCaptureMode &lt;&gt; 3 then ' we are not doing both pre and post images
                SwitchToRaman           ' then restore the Raman path.
            end if 
        end if
    End Sub

    Private Sub InitInstrument()
        Set m_oInstrumentState = InstrumentState 'CreateObject("Renishaw.WiREInstStateCom")
        Set m_oInstrument = new CInstrument
        m_oInstrument.Init m_oInstrumentState, System, g_doorOpenWarningIgnored
        'm_oInstrumentState.InitialiseFromSystem
    End Sub
    
    Public Sub SwitchToWhitelight()
        Logger.Debug "Switching to whitelight for image capture"
        On Error Resume Next
        Instrument.ApplyWhitelight m_bIllumLampOn, m_nLampBrightness
        If Err.Number &lt;&gt; 0 Then Logger.Warn Err.Source &amp; ": " &amp; Err.Description
        On Error Goto 0
    End Sub

    Public Sub SwitchToRaman()
        Logger.Debug "Switching to raman signal after image capture"
        On Error Resume Next
        Instrument.Apply
        If Err.Number &lt;&gt; 0 Then Logger.Warn Err.Source &amp; ": " &amp; Err.Description
        On Error Goto 0
    End Sub

    Public Sub UpdateDataset()
        If (Not(m_oPreImage Is Nothing) OR Not(m_oPostImage Is Nothing)) Then
            Scan.UpdatePrePostImages m_oPreImage, m_oPostImage
        End If
    End Sub
    
    Public Sub Reset()
        'Logger.Debug "ImageCapture.Reset"
        Set m_oPreImage = Nothing
        Set m_oPostImage = Nothing
        m_sPrePath = ""
        m_sPostPath = ""
    End Sub
End Class

' ---
' Checksum: 0x00000000
' ---</Code><Status vt:type="VT_UI4">0</Status><System vt:type="VT_BSTR"></System><DataFileFormat vt:type="VT_UI4">9</DataFileFormat><DataSaveMode vt:type="VT_UI4">3</DataSaveMode><DataSaveFile vt:type="VT_BSTR">D:\Temp\Temp\ren9C05.wdf</DataSaveFile><ExportToSPC vt:type="VT_BOOL">0</ExportToSPC><ExportToTXT vt:type="VT_BOOL">0</ExportToTXT><NamedItems vt:type="VT_UNKNOWN" clsid="{EA41D175-63DA-11D5-84E9-009027FE0FB4}" xmlns:vt="urn:renishaw:vartypes"><_nitems vt:type="VT_I4">2</_nitems><_key0 vt:type="VT_BSTR">InstrumentState</_key0><InstrumentState vt:type="VT_DISPATCH" clsid="{9E341908-F390-4472-82EA-F7EC3CD5E020}" xmlns:vt="urn:renishaw:vartypes"><AreaKey vt:type="VT_UNKNOWN" clsid="{F22A2AF6-94E0-4814-B38B-68C824427192}" xmlns:vt="urn:renishaw:vartypes"><Laser.20Name vt:type="VT_BSTR">laser1</Laser.20Name><BeamPath vt:type="VT_INT">2</BeamPath><Focus.20Mode vt:type="VT_INT">1</Focus.20Mode><Grating.20Name vt:type="VT_BSTR">grating1</Grating.20Name><LensSetID vt:type="VT_INT">0</LensSetID><id vt:type="VT_INT">8</id><detID vt:type="VT_INT">1</detID></AreaKey><slitBias vt:type="VT_R8">0</slitBias><slitOpening vt:type="VT_R8">10</slitOpening><NDPercent vt:type="VT_R8">100</NDPercent><BeamDefocus vt:type="VT_R8">0</BeamDefocus><PoduleUpper vt:type="VT_I4">1</PoduleUpper><PoduleLower vt:type="VT_I4">3</PoduleLower><ShutterOpen vt:type="VT_I4">1</ShutterOpen><Pinhole_In vt:type="VT_I4">0</Pinhole_In><CalLamp_On vt:type="VT_I4">0</CalLamp_On><CalLamp_Intensity vt:type="VT_I4">100</CalLamp_Intensity><IllumLamp_On vt:type="VT_I4">0</IllumLamp_On><IllumLamp_Intensity vt:type="VT_I4">100</IllumLamp_Intensity><NeonLamp_On vt:type="VT_I4">0</NeonLamp_On><linefocus_In vt:type="VT_I4">0</linefocus_In><WaveplatePos vt:type="VT_R8">0</WaveplatePos><PodulePath vt:type="VT_I4">2</PodulePath><RunSilent vt:type="VT_BOOL">0</RunSilent><FOPMirrorPos vt:type="VT_I4">1</FOPMirrorPos><Lightpath vt:type="VT_BSTR"></Lightpath><LT_Filter_ND_IN vt:type="VT_I4">0</LT_Filter_ND_IN></InstrumentState><_key1 vt:type="VT_BSTR">Scan</_key1><Scan vt:type="VT_DISPATCH" clsid="{065E4E4C-46D7-495D-A42B-02776B9B1EB7}" xmlns:vt="urn:renishaw:vartypes"><Centre.20Wavenumber vt:type="VT_R8">720</Centre.20Wavenumber><First.20Wavenumber vt:type="VT_R8">58.5840652688385</First.20Wavenumber><Last.20Wavenumber vt:type="VT_R8">1318.518053008</Last.20Wavenumber><DefaultRangeIsOverriden vt:type="VT_BOOL">0</DefaultRangeIsOverriden><scan.20Area.20Key vt:type="VT_UNKNOWN" clsid="{F22A2AF6-94E0-4814-B38B-68C824427192}" xmlns:vt="urn:renishaw:vartypes"><Laser.20Name vt:type="VT_BSTR">laser1</Laser.20Name><BeamPath vt:type="VT_INT">2</BeamPath><Focus.20Mode vt:type="VT_INT">1</Focus.20Mode><Grating.20Name vt:type="VT_BSTR">grating1</Grating.20Name><LensSetID vt:type="VT_INT">0</LensSetID><id vt:type="VT_INT">8</id><detID vt:type="VT_INT">1</detID></scan.20Area.20Key><X.20Binning vt:type="VT_INT">1</X.20Binning><y.20Binning vt:type="VT_INT">11</y.20Binning><Accumulations vt:type="VT_INT">1</Accumulations><Exposure.20Time vt:type="VT_INT">1000</Exposure.20Time><Units vt:type="VT_INT">1</Units><monitoring vt:type="VT_INT">0</monitoring><use.20MultiTrack vt:type="VT_INT">0</use.20MultiTrack><Use.20Cosmic.20Ray.20Remove vt:type="VT_INT">0</Use.20Cosmic.20Ray.20Remove><Camera.20Gain.20High vt:type="VT_INT">1</Camera.20Gain.20High><Camera.20Speed.20High vt:type="VT_INT">0</Camera.20Speed.20High><using.20WiRE2.20Diagnostics vt:type="VT_INT">1</using.20WiRE2.20Diagnostics><save.20Data.20As.20Single.20Spectrum vt:type="VT_INT">0</save.20Data.20As.20Single.20Spectrum><use.20Area.20Binning vt:type="VT_INT">0</use.20Area.20Binning><Use.20Pixel.20intensity vt:type="VT_UI1">1</Use.20Pixel.20intensity><nMapScans vt:type="VT_I4">1</nMapScans><useResponse vt:type="VT_BOOL">0</useResponse><ignoreZelDac vt:type="VT_BOOL">0</ignoreZelDac><SoftTriggers vt:type="VT_I4">0</SoftTriggers><track vt:type="VT_I4">1</track><useFullArea vt:type="VT_BOOL">0</useFullArea><mtrSteps vt:type="VT_UNKNOWN" clsid="{6493207B-3132-46CC-BBE3-C915C277E83B}" xmlns:vt="urn:renishaw:vartypes"><_nitems vt:type="VT_I4">0</_nitems><ReadOnlyFlag vt:type="VT_BOOL">0</ReadOnlyFlag></mtrSteps><CloseLSForRead vt:type="VT_UI1">0</CloseLSForRead><MatchOverlap vt:type="VT_UI1">0</MatchOverlap><MatchOverlapMultiplicative vt:type="VT_UI1">1</MatchOverlapMultiplicative><DisableLiveTrackDuringStepAndRepeat vt:type="VT_UI1">0</DisableLiveTrackDuringStepAndRepeat><UseEMGain vt:type="VT_BOOL">0</UseEMGain><EMGainValue vt:type="VT_INT">0</EMGainValue><StreamSpotChargeClearThreshold vt:type="VT_INT">1000</StreamSpotChargeClearThreshold><detectorChannelIndex vt:type="VT_INT">1</detectorChannelIndex><SaturationProtectionLimit vt:type="VT_I4">0</SaturationProtectionLimit><use.20fast.20time.20series vt:type="VT_UI1">0</use.20fast.20time.20series><time.20series.20count vt:type="VT_I4">0</time.20series.20count><Discard.20rows vt:type="VT_I4">0</Discard.20rows><time.20series.20delay vt:type="VT_I4">0</time.20series.20delay></Scan></NamedItems><Properties vt:type="VT_UNKNOWN" clsid="{C0795962-BCD1-4C1E-9A6D-D22CC237B73C}" xmlns:vt="urn:renishaw:vartypes"><_nitems vt:type="VT_I4">23</_nitems><_key0 vt:type="VT_BSTR">AcquisitionCount</_key0><AcquisitionCount vt:type="VT_I4">1</AcquisitionCount><_key1 vt:type="VT_BSTR">BleachTime</_key1><BleachTime vt:type="VT_I4">0</BleachTime><_key2 vt:type="VT_BSTR">closeLaserShutter</_key2><closeLaserShutter vt:type="VT_BOOL">-1</closeLaserShutter><_key3 vt:type="VT_BSTR">CreationTime</_key3><CreationTime vt:type="VT_DATE">04/06/2021 06:40:47</CreationTime><_key4 vt:type="VT_BSTR">DepthSeriesStartPos</_key4><DepthSeriesStartPos vt:type="VT_R8">-0.640625</DepthSeriesStartPos><_key5 vt:type="VT_BSTR">FocusTrackEnabled</_key5><FocusTrackEnabled vt:type="VT_BOOL">0</FocusTrackEnabled><_key6 vt:type="VT_BSTR">FocusTrackInterval</_key6><FocusTrackInterval vt:type="VT_R8">1</FocusTrackInterval><_key7 vt:type="VT_BSTR">illuminationLampBrightnessPercent</_key7><illuminationLampBrightnessPercent vt:type="VT_I4">40</illuminationLampBrightnessPercent><_key8 vt:type="VT_BSTR">illuminationLampOn</_key8><illuminationLampOn vt:type="VT_BOOL">-1</illuminationLampOn><_key9 vt:type="VT_BSTR">LUT_Auto</_key9><LUT_Auto vt:type="VT_I2">-1</LUT_Auto><_key10 vt:type="VT_BSTR">MeasurementType</_key10><MeasurementType vt:type="VT_BSTR">SingleScan</MeasurementType><_key11 vt:type="VT_BSTR">minimizeLaserExposure</_key11><minimizeLaserExposure vt:type="VT_BOOL">0</minimizeLaserExposure><_key12 vt:type="VT_BSTR">Operator</_key12><Operator vt:type="VT_BSTR">Raman</Operator><_key13 vt:type="VT_BSTR">PAFEnabled</_key13><PAFEnabled vt:type="VT_BOOL">0</PAFEnabled><_key14 vt:type="VT_BSTR">PlugIns</_key14><PlugIns vt:type="VT_DISPATCH" clsid="{D9303A2E-17E8-416C-AA67-9B0B4B2D8A19}" xmlns:vt="urn:renishaw:vartypes"><Count vt:type="VT_I4">0</Count><ReadOnly vt:type="VT_I2">0</ReadOnly></PlugIns><_key15 vt:type="VT_BSTR">responseCalibration</_key15><responseCalibration vt:type="VT_BOOL">0</responseCalibration><_key16 vt:type="VT_BSTR">restoreInstrumentState</_key16><restoreInstrumentState vt:type="VT_BOOL">0</restoreInstrumentState><_key17 vt:type="VT_BSTR">TimeSeriesCount</_key17><TimeSeriesCount vt:type="VT_I4">1</TimeSeriesCount><_key18 vt:type="VT_BSTR">TimeSeriesInterval</_key18><TimeSeriesInterval vt:type="VT_I4">0</TimeSeriesInterval><_key19 vt:type="VT_BSTR">useExternalSignalMapping</_key19><useExternalSignalMapping vt:type="VT_BOOL">0</useExternalSignalMapping><_key20 vt:type="VT_BSTR">usePerformanceQualification</_key20><usePerformanceQualification vt:type="VT_BOOL">0</usePerformanceQualification><_key21 vt:type="VT_BSTR">userWarnedAboutScanLaserMismatch</_key21><userWarnedAboutScanLaserMismatch vt:type="VT_BOOL">0</userWarnedAboutScanLaserMismatch><_key22 vt:type="VT_BSTR">wizardclsid</_key22><wizardclsid vt:type="VT_BSTR">{7A6C14A3-DBB1-4101-A6C7-1D0D58988EF1}</wizardclsid></Properties></Measurement></MeasurementInformation><ViewInformation><Viewer ID="ControlBar0"><BarState><clsid dt:dt="string">{00000000-0000-0000-0000-000000000000}</clsid><BarID dt:dt="ui2">59419</BarID><Bars dt:dt="i4">3</Bars><Bar0 dt:dt="i4">0</Bar0><Bar1 dt:dt="i4">125</Bar1><Bar2 dt:dt="i4">0</Bar2></BarState></Viewer><Viewer ID="Viewer0"><BarState><ControlType dt:dt="i4">0</ControlType><clsid dt:dt="string">{8DD949CD-AF27-11D4-932A-0050044F4BA1}</clsid><BarID dt:dt="ui2">125</BarID><PropertyBag clsid="{8DD949CD-AF27-11D4-932A-0050044F4BA1}" xmlns:vt="urn:renishaw:vartypes"><SpectrumViewerName vt:type="VT_BSTR">Spectrum Viewer 1</SpectrumViewerName><_cx vt:type="VT_UI4">35243</_cx><_cy vt:type="VT_UI4">9446</_cy><YAxisHeightFraction vt:type="VT_R8">0.15</YAxisHeightFraction><ActiveSpectrumColour vt:type="VT_UI4">255</ActiveSpectrumColour><AutoYAxisCaptionText vt:type="VT_BOOL">-1</AutoYAxisCaptionText><AutoXAxisCaptionText vt:type="VT_BOOL">-1</AutoXAxisCaptionText><ShowViewAreaBorder vt:type="VT_BOOL">0</ShowViewAreaBorder><ShowCursor vt:type="VT_BOOL">-1</ShowCursor><ReverseY vt:type="VT_BOOL">0</ReverseY><ReverseX vt:type="VT_BOOL">0</ReverseX><ForceCursorToData vt:type="VT_BOOL">0</ForceCursorToData><ShowXAxis vt:type="VT_BOOL">-1</ShowXAxis><ShowYAxis vt:type="VT_BOOL">-1</ShowYAxis><AutoscaleFirstSpectrumOnOpen vt:type="VT_BOOL">25957</AutoscaleFirstSpectrumOnOpen><AutoscaleOnOpen vt:type="VT_BOOL">-1</AutoscaleOnOpen><CaptionBold vt:type="VT_BOOL">25957</CaptionBold><SameXLimits vt:type="VT_BOOL">-1</SameXLimits><SameYLimits vt:type="VT_BOOL">0</SameYLimits><CursorThickness vt:type="VT_I4">1</CursorThickness><XCursorPos vt:type="VT_I4">6332</XCursorPos><YCursorPos vt:type="VT_I4">-18193</YCursorPos><YDisplayFraction vt:type="VT_R8">0.85</YDisplayFraction><XAxisHeightFraction vt:type="VT_R8">0.168067226890756</XAxisHeightFraction><XAxisWidthFraction vt:type="VT_R8">0.15</XAxisWidthFraction><YAxisHeightFraction vt:type="VT_R8">0.15</YAxisHeightFraction><YAxisWidthFraction vt:type="VT_R8">6.38138138138138E-02</YAxisWidthFraction><XEndOversizeFraction vt:type="VT_R8">0.02</XEndOversizeFraction><XCursorLogicalPos vt:type="VT_R8">51.2050532551895</XCursorLogicalPos><YCursorLogicalPos vt:type="VT_R8">637.603893460167</YCursorLogicalPos><XDisplayFraction vt:type="VT_R8">1</XDisplayFraction><DragMode vt:type="VT_I4">0</DragMode><TrackMode vt:type="VT_I4">1</TrackMode><CursorStyle vt:type="VT_I4">0</CursorStyle><BackgroundColour vt:type="VT_I4">16777215</BackgroundColour><ActiveSpectrumColour vt:type="VT_I4">255</ActiveSpectrumColour><AxisColour vt:type="VT_I4">0</AxisColour><XEndOversizeFraction vt:type="VT_R8">0.02</XEndOversizeFraction><YEndOversizeFraction vt:type="VT_R8">0.02</YEndOversizeFraction><XStartOversizeFraction vt:type="VT_R8">0</XStartOversizeFraction><YStartOversizeFraction vt:type="VT_R8">0</YStartOversizeFraction><XMinorTickHeight vt:type="VT_R8">0.4</XMinorTickHeight><YMinorTickHeight vt:type="VT_R8">0.4</YMinorTickHeight><XStartRange vt:type="VT_R8">0</XStartRange><YStartRange vt:type="VT_R8">0</YStartRange><XEndRange vt:type="VT_R8">10</XEndRange><YEndRange vt:type="VT_R8">10</YEndRange><XMajorTickLength vt:type="VT_R8">0.15</XMajorTickLength><YMajorTickLength vt:type="VT_R8">0.15</YMajorTickLength><XLabelDrawSpace vt:type="VT_R8">0.4</XLabelDrawSpace><YLabelDrawSpace vt:type="VT_R8">0.4</YLabelDrawSpace><XTickLabelWhiteSpace vt:type="VT_R8">0.1</XTickLabelWhiteSpace><YTickLabelWhiteSpace vt:type="VT_R8">0.1</YTickLabelWhiteSpace><XCaptionDrawSpace vt:type="VT_R8">0.3</XCaptionDrawSpace><YCaptionDrawSpace vt:type="VT_R8">0.3</YCaptionDrawSpace><XLabelCaptionWhiteSpace vt:type="VT_R8">0.05</XLabelCaptionWhiteSpace><YLabelCaptionWhiteSpace vt:type="VT_R8">0.05</YLabelCaptionWhiteSpace><XCaptionSize vt:type="VT_R8">-13</XCaptionSize><YCaptionSize vt:type="VT_R8">-13</YCaptionSize><XLabelSize vt:type="VT_R8">-11</XLabelSize><YLabelSize vt:type="VT_R8">-11</YLabelSize><FixXAxisThickness vt:type="VT_BOOL">-1</FixXAxisThickness><FixYAxisThickness vt:type="VT_BOOL">-1</FixYAxisThickness><FixedXAxisThickness vt:type="VT_R8">60</FixedXAxisThickness><FixedYAxisThickness vt:type="VT_R8">85</FixedYAxisThickness><XLowerExponential vt:type="VT_I4">-2</XLowerExponential><YLowerExponential vt:type="VT_I4">-2</YLowerExponential><XUpperExponential vt:type="VT_I4">6</XUpperExponential><YUpperExponential vt:type="VT_I4">6</YUpperExponential><XLabelFontHeight vt:type="VT_I4">14</XLabelFontHeight><YLabelFontHeight vt:type="VT_I4">14</YLabelFontHeight><XShowLabels vt:type="VT_BOOL">-1</XShowLabels><YShowLabels vt:type="VT_BOOL">-1</YShowLabels><XShowMajorTicks vt:type="VT_BOOL">-1</XShowMajorTicks><YShowMajorTicks vt:type="VT_BOOL">-1</YShowMajorTicks><XShowMinorTicks vt:type="VT_BOOL">-1</XShowMinorTicks><YShowMinorTicks vt:type="VT_BOOL">-1</YShowMinorTicks><XExpLabels vt:type="VT_BOOL">0</XExpLabels><YExpLabels vt:type="VT_BOOL">0</YExpLabels><XAutoFontSize vt:type="VT_BOOL">0</XAutoFontSize><YAutoFontSize vt:type="VT_BOOL">0</YAutoFontSize><XShowCaptionText vt:type="VT_BOOL">-1</XShowCaptionText><YShowCaptionText vt:type="VT_BOOL">-1</YShowCaptionText><XCaptionUnderline vt:type="VT_BOOL">0</XCaptionUnderline><YCaptionUnderline vt:type="VT_BOOL">0</YCaptionUnderline><XCaptionStrikeThru vt:type="VT_BOOL">0</XCaptionStrikeThru><YCaptionStrikeThru vt:type="VT_BOOL">0</YCaptionStrikeThru><XCaptionItalic vt:type="VT_BOOL">0</XCaptionItalic><YCaptionItalic vt:type="VT_BOOL">0</YCaptionItalic><XCaptionBold vt:type="VT_BOOL">0</XCaptionBold><YCaptionBold vt:type="VT_BOOL">0</YCaptionBold><XLabelUnderline vt:type="VT_BOOL">0</XLabelUnderline><YLabelUnderline vt:type="VT_BOOL">0</YLabelUnderline><XLabelStrikeThru vt:type="VT_BOOL">0</XLabelStrikeThru><YLabelStrikeThru vt:type="VT_BOOL">0</YLabelStrikeThru><XLabelItalic vt:type="VT_BOOL">0</XLabelItalic><YLabelItalic vt:type="VT_BOOL">0</YLabelItalic><XLabelBold vt:type="VT_BOOL">0</XLabelBold><YLabelBold vt:type="VT_BOOL">0</YLabelBold><XMinorTickThickness vt:type="VT_I4">1</XMinorTickThickness><YMinorTickThickness vt:type="VT_I4">1</YMinorTickThickness><XMinMinorTicks vt:type="VT_I4">3</XMinMinorTicks><YMinMinorTicks vt:type="VT_I4">3</YMinMinorTicks><XMinTicks vt:type="VT_I4">4</XMinTicks><YMinTicks vt:type="VT_I4">4</YMinTicks><XAxisThickness vt:type="VT_I4">1</XAxisThickness><YAxisThickness vt:type="VT_I4">1</YAxisThickness><XMajorTickThickness vt:type="VT_I4">1</XMajorTickThickness><YMajorTickThickness vt:type="VT_I4">1</YMajorTickThickness><XCaptionColor vt:type="VT_I4">0</XCaptionColor><YCaptionColor vt:type="VT_I4">0</YCaptionColor><XLabelColor vt:type="VT_I4">0</XLabelColor><YLabelColor vt:type="VT_I4">0</YLabelColor><XAxisColor vt:type="VT_I4">0</XAxisColor><YAxisColor vt:type="VT_I4">0</YAxisColor><XCaptionFontName vt:type="VT_BSTR">Arial</XCaptionFontName><YCaptionFontName vt:type="VT_BSTR">Arial</YCaptionFontName><XCaption vt:type="VT_BSTR"></XCaption><YCaption vt:type="VT_BSTR"></YCaption><XLabelFontName vt:type="VT_BSTR">Arial</XLabelFontName><YLabelFontName vt:type="VT_BSTR">Arial</YLabelFontName><XTextAlignment vt:type="VT_I4">0</XTextAlignment><YTextAlignment vt:type="VT_I4">0</YTextAlignment><DisplaySpectrumMode vt:type="VT_I4">0</DisplaySpectrumMode><AutoFontSize vt:type="VT_BOOL">0</AutoFontSize><plotmode vt:type="VT_I4">0</plotmode><nDefLineThickness vt:type="VT_I4">1</nDefLineThickness><TitleShow vt:type="VT_I4">0</TitleShow><TitleBorder vt:type="VT_I4">2</TitleBorder><cdTitle vt:type="VT_BSTR"></cdTitle><MarginTop vt:type="VT_I4">0</MarginTop><titlePos vt:type="VT_I4">0</titlePos><LabelsVertical vt:type="VT_BOOL">0</LabelsVertical><satDisplay vt:type="VT_I4">1</satDisplay><UseAntiAlias vt:type="VT_BOOL">0</UseAntiAlias><ActiveSpectrumMode vt:type="VT_I4">0</ActiveSpectrumMode><ActiveSpectrumThickness vt:type="VT_I4">4</ActiveSpectrumThickness><ActiveSpectrumOpacity vt:type="VT_I4">75</ActiveSpectrumOpacity><MarginBottom vt:type="VT_I4">0</MarginBottom><ShowXUnitsWithCaptionOverride vt:type="VT_BOOL">0</ShowXUnitsWithCaptionOverride><MonitorHistoryCount vt:type="VT_I4">0</MonitorHistoryCount><PerDSLabels vt:type="VT_DISPATCH" clsid="{96BC0211-6B9D-4094-9A09-2CC8E533EA3A}" xmlns:vt="urn:renishaw:vartypes"><use vt:type="VT_BOOL">0</use><txBkg vt:type="VT_BOOL">0</txBkg><border vt:type="VT_BOOL">49</border><colouredText vt:type="VT_BOOL">0</colouredText><showX vt:type="VT_BOOL">-1</showX><showY vt:type="VT_BOOL">-1</showY><showZ vt:type="VT_BOOL">-1</showZ><showTemp vt:type="VT_BOOL">-1</showTemp><showRamp vt:type="VT_BOOL">-1</showRamp><showAcq vt:type="VT_BOOL">-1</showAcq><showDsi vt:type="VT_BOOL">0</showDsi><showTime vt:type="VT_BOOL">0</showTime><mode vt:type="VT_INT">0</mode><showFile vt:type="VT_INT">2</showFile><showFT vt:type="VT_BOOL">0</showFT><showMPM vt:type="VT_BOOL">-1</showMPM><noofDP vt:type="VT_INT">1</noofDP></PerDSLabels></PropertyBag><XPos dt:dt="i4">-2</XPos><YPos dt:dt="i4">-2</YPos><Docking dt:dt="i4">1</Docking><MRUDockID dt:dt="ui2">0</MRUDockID><MRUDockLeftPos dt:dt="i4">-2</MRUDockLeftPos><MRUDockTopPos dt:dt="i4">-2</MRUDockTopPos><MRUDockRightPos dt:dt="i4">1352</MRUDockRightPos><MRUDockBottomPos dt:dt="i4">365</MRUDockBottomPos><MRUFloatStyle dt:dt="ui4">8196</MRUFloatStyle><MRUFloatXPos dt:dt="i4">-1</MRUFloatXPos><MRUFloatYPos dt:dt="i4">0</MRUFloatYPos><WiREControlPosition><sizeHorzCX dt:dt="i4">1354</sizeHorzCX><sizeHorzCY dt:dt="i4">367</sizeHorzCY><sizeVertCX dt:dt="i4">552</sizeVertCX><sizeVertCY dt:dt="i4">367</sizeVertCY><sizeFloatCX dt:dt="i4">552</sizeFloatCX><sizeFloatCY dt:dt="i4">367</sizeFloatCY><Style dt:dt="ui4">12212</Style><DockStyle dt:dt="ui4">61440</DockStyle></WiREControlPosition></BarState></Viewer><Summary><WiREBars dt:dt="i4">1</WiREBars><Bars dt:dt="i4">1</Bars><ScreenCX dt:dt="i4">1920</ScreenCX><ScreenCY dt:dt="i4">1200</ScreenCY><Toolbars dt:dt="i4">0</Toolbars></Summary></ViewInformation></WiREXMLDoc>
